#!/bin/bash

# ncupgrade by BernieO - upgrades Nextcloud to desired version (see examples/ncupgrade.conf)
# Source: https://github.com/BernieO/ncupgrade
# Copyright (C) 2017 BernieO
#
# This script is licensed under the GNU AFFERO GENERAL PUBLIC LICENSE v3.0
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


#######################################################
#######################################################
##                                                   ##
##    Don't touch  anything below unless you know    ##
##           exactly what you are doing!             ##
##                                                   ##
#######################################################
#######################################################

print_header() {
# prints a nice header with welcome message and advice to have a backup

  echo "+++++++++++++++++++++++++++++++++++++"
  echo "+"
  echo "+  This script will upgrade your Nextcloud installation."
  echo "+  Use at own risk!"
  echo "+"
  echo "+  ATTENTION BEFORE PROCEEDING:"
  echo "+    - back up your database!"
  echo "+    - back up Nextclouds data directory, if it is located outside of Nextclouds directory!"
  echo "+  See README.md for instructions how to back up."
  echo "+"
}

ask_for_version() {
# asks for version Nextcloud shall be upgraded to, makes sure a valid value is entered and assigns archive name for download

  echo "+  To which version do you want to upgrade your Nextcloud?"
  echo "+  Please enter (X needs to be a digit):"
  echo "+    - either version string XX.X.X (e.g. '13.0.0')"
  echo "+    - or 'latest-XX' to upgrade to latest available version of main version XX"
  echo "+    - or 'latest' to upgrade to latest available version"

  # regex allows only "XX.X.XX", "latest" or "latest-XX" (X must be a digit):
  regex='^([[:digit:]]{1,2}\.[[:digit:]]{1}\.[[:digit:]]{1,2}|latest(-[[:digit:]]{1,2})?)$'

  # ask for version to be upgraded to (and repeat if no valid value was entered):
  while [[ -z "${upgrade_to_version:-}" ]]; do
    read -r -p "+  Upgrade to version: " upgrade_to_version
    if [[ ! "${upgrade_to_version}" =~ ${regex} ]]; then
      echo "-- ERROR: not a valid value! Try again."
      echo "+  either enter version number (e.g. '13.0.0'), 'latest-XX' or 'latest'"
      unset upgrade_to_version
    else
      # if valid value was entered - ask for confirmation, to make sure there is no typo:
      while read -r -n 1 -p "+  Confirm upgrade to version '${upgrade_to_version}' (Y/N): " sure; do
        if [[ ${sure} = [YyNn] ]]; then
          [[ ${sure} = [Yy] ]] && {
            # if confirmed (Y or y): exit the while loop and proceed:
            printf "\n%s\n" "+  Confirmed. Starting upgrade"
            break
          }
          [[ ${sure} = [Nn] ]] && {
            # if not confirmed (N or n) error and exit:
            printf "\n%s\n" "-- ERROR: upgrade to ${upgrade_to_version} not confirmed. Exiting"
            exit 1
          }
        else
          # if not a valid value was entered - print newline and repeat while loop:
          printf "\n"
        fi
      done
    fi
  done

  # assign archive name according to entered version (using tar.bz2, because zip doesn't contain permissions):
  if [[ "${upgrade_to_version}" =~ latest ]]; then
    # if 'latest' or 'latest-XX' was given it is enough to append '.tar.bz2':
    nextcloud_archive="${upgrade_to_version}.tar.bz2"
  else
    # if version number was given, archive is named nextcloud-XX.X.XX.tar.bz2:
    nextcloud_archive="nextcloud-${upgrade_to_version}.tar.bz2"
  fi
}

read_configfile() {
# reads ncupgrades configfile ncupgrade.conf

  # check for existing ncupgrade onfig file:
  if [[ -f ncupgrade.conf ]]; then
    # read config file - this file needs to reside in the same directory as this script (see examples/ncupgrade.conf):
    echo "+  reading configuration file ncupgrade.conf"
    . ncupgrade.conf
  else
    # if no configuration file next to this script error and exit:
    echo "-- ERROR: Configuration file ncupgrade.conf not found."
    echo "-- This file needs to be in the same directory as this script."
    echo "-- See examples/ncupgrade.conf.example - Exiting."
    exit 1
  fi
}

maintenance_mode() {
# enables or disables Nextclouds maintenance mode (depending on $1: on|off)

  local text

  [[ "${1}" == "on" ]] && text="enabl"
  [[ "${1}" == "off" ]] && text="disabl"
  printf "%s" "+  ${text}ing Nextclouds maintenance mode... "
  sudo -u ${htuser} php "${nextcloud_dir}/occ" --no-warnings maintenance:mode --${1}
}

create_temp_dir() {
# creates a temporary directory

  # create timestamp to append to backups:
  now=$(date +"%Y.%m.%d-%H.%M")

  echo "+  creating temporary directory"

  # store temp-directory in variable:
  temp_dir="/tmp/ncupgrade"

  mkdir -p "${temp_dir}"
  cd "${temp_dir}"

  # remove eventually existing files from previous run of this script (suppress error, if nothing is there to be removed):
  rm -r * > /dev/null 2>&1
}

get_nc_config_value() {
# reads value ($1) from Nextclouds system configuration

  local value

  value="$(sudo -u ${htuser} php "${nextcloud_dir}/occ" --no-warnings config:system:get ${1})"
  echo "${value}"
}

compress_backup() {
# compresses backed up and moves compressed backup to backup folder
# arguments:
#       $1 - path to be compressed (file or directory)
#       $2 - path (directory) under which the compressed file shall be saved

  local original_dir compress_error

  # store current directory (to be able to switch back):
  original_dir="$(pwd)"
  # change to directory that contains the directory or file to be compressed:
  cd "${1%/*}"

  # compress backup using the configured method (zip or tar.gz):
  if [[ "${compression_method}" == "zip" ]]; then
    # use zip to compress file or directory:
    zip -r -q "${2}/${1##*/}_${now}.zip" "${1##*/}"
    # store error, to be able to print error message:
    [[ $? -eq 0 ]] || compress_error="1"
  else
    # use "tar.gz" as compression_method, in case invalid value was entered:
    compression_method="tar.gz"
    # use tar.gz to compress folder with backed up files:
    tar -czf "${2}/${1##*/}_${now}.tar.gz" "${1##*/}"
    # store error, to be able to print error message:
    [[ $? -eq 0 ]] || compress_error="1"
  fi
  # print error message, if an error occured
  [[ "${compress_error}" == "1" ]] && printf "\n%s\n" "-- ERROR: Compressing the files produced an error. See lines right above."

  # change back to original directory:
  cd "${original_dir}"
}

backup_database() {
# creates a backup of Nextclouds database tables

  local dbtype dbhost dbprotocol dbname dbuser dbpassword PGPASSWORD

  printf "%s" "+  backing up database... "

  # first we need to find out which type of database is used (SQLite3, MySQL/MariaDB, PostgreSQL)
  dbtype="$(get_nc_config_value "dbtype")"

  if [[ "$dbtype" != "sqlite3" ]]; then
    # if database is not SQLite3 - we also need more things to know (dbhost, dbname, dbuser, dbpassword)
    dbhost="$(get_nc_config_value "dbhost")"
    dbname="$(get_nc_config_value "dbname")"
    dbuser="$(get_nc_config_value "dbuser")"
    dbpassword="$(get_nc_config_value "dbpassword")"

    # check whether dbhost contains socket (e.g. 'localhost:/path/to/socket') or portnumber (e.g. 'localhost:3306')
    #   and store it for commands:
    if [[ "${dbhost}" =~ ^.+:/.+$ ]]; then
      # dbhost contains socket after hostname (e.g. 'localhost:/var/run/mysqld/mysqld.sock'):
      if [[ "${dbtype}" == "mysql" ]]; then
        # specify socket and host for MySQL/MariaDB
        dbprotocol="--socket=${dbhost#*:}"
        dbhost="${dbhost%%:*}"
      elif [[ "${dbtype}" == "pgsql" ]]; then
        # use socket as host for PostgreSQL - see: https://www.postgresql.org/docs/current/static/app-pgdump.html:
        dbprotocol=""
        dbhost="${dbhost#*:}"
      fi
    elif [[ "${dbhost}" =~ ^.+:[[:digit:]]+$ ]]; then
      # dbhost contains portnumber after hostname (e.g. '127.0.0.1:3306'):
      dbprotocol="--port=${dbhost#*:}"
      dbhost="${dbhost%%:*}"
    else
      # dbhost contains only hostname - use empty value to tell database-command to use default value:
      dbprotocol=""
    fi

    if [[  "$dbtype" == "mysql" ]]; then
      # dump MySQL/MariaDB database:
      mysqldump --single-transaction -h ${dbhost} ${dbprotocol} -u ${dbuser} -p${dbpassword} ${dbname} > "${temp_dir}/nextcloud-sqlbkp.bak"
    elif [[ "$dbtype" == "pgsql" ]]; then
      # dump PostgreSQL database:
      PGPASSWORD="${dbpassword}" pg_dump ${dbname} -h ${dbhost} ${dbprotocol} -U ${dbuser} -f "${temp_dir}/nextcloud-sqlbkp.bak"
    fi
    # unset sensitive data:
    unset PGPASSWORD dbpassword dbuser

  elif [[ "$dbtype" == "sqlite3" ]]; then
    # dump sqlite3 database:
    sqlite3 ${nc_data_dir}/owncloud.db .dump > "${temp_dir}/nextcloud-sqlbkp.bak"
  fi

  # compress database backup and move it to backup folder:
  compress_backup "${temp_dir}/nextcloud-sqlbkp.bak" "${backup_dir}"

  printf "%s\n" "done!"
}

backup_data_dir() {
# stores a compressed backup of Nextclouds data directory in backup directory

  local regex

  # check whether data directory is located inside nextcloud directory:
  regex="^${nextcloud_dir}*"
  if [[ "${nc_data_dir}" =~ ${regex} ]]; then
    echo "+  no need to back up data directory (located inside Nextcloud directory which will be backed up later anyway)"
  else
    printf "%s" "+  backing up data directory (located outside of Nextcloud folder)... "
    # compress data directory and store it in backup directory:
    compress_backup "${nc_data_dir}" "${backup_dir}"
    printf "%s\n" "done!"
  fi
}

backup_nc_dir() {
# stores a compressed backup of Nextclouds directory in backup directory

  printf "%s" "+  backing up Nextcloud directory... "
  # compress data directory and store it in backup directory:
  compress_backup "${nextcloud_dir}" "${backup_dir}"
  printf "%s\n" "done!"
}

create_backup() {
# creates backup of Nextcloud installation based on official documentation:
# https://github.com/nextcloud/documentation/blob/master/admin_manual/maintenance/backup.rst

  # create backup directory (in case it does not exist yet):
  mkdir -p "${backup_dir}"

  # make sure we know the location of Nextclouds data directory:
  [[ -z ${nc_data_dir:-} ]] && nc_data_dir="$(get_nc_config_value "datadirectory")"

  # Maintenance mode is already enabled at this stage of this script

  # Backup folders:
  backup_data_dir   # back up Nextclouds data directory (in case it is located outside Nextclouds directory)
  backup_nc_dir     # back up Nextcloud directory (contains then also config.php, themes and 3rd party apps)

  # Backup database:
  backup_database
}

download_archive() {
# downloads Nextcloud archive, according SHA512 checksum and according PGP signature

  printf "%s" "+  downloading Nextcloud archive '${nextcloud_archive}', according checksum and PGP signature..."
  curl -sS -O "https://download.nextcloud.com/server/releases/${nextcloud_archive}"
  curl -sS -O "https://download.nextcloud.com/server/releases/${nextcloud_archive}.sha512"
  curl -sS -O "https://download.nextcloud.com/server/releases/${nextcloud_archive}.asc"
  printf "%s\n" " done!"
}

verify_checksum() {
# verifies SHA512 checksum of archive

  printf "%s" "+  verifying SHA512 checksum of downloaded archive... "
  sha512sum -c "${nextcloud_archive}.sha512" < "${nextcloud_archive}"
  # error and exit, if checksum test failed:
  if [[ $? != 0 ]]; then
    printf "\n%s\n" "-- ERROR: checksum test failed. Downloaded archive seems to be corrupt. Exiting"
    exit 1
  fi
}

verify_signature() {
# verifies PHP signature of archive

  printf "%s" "+  verifying PGP signature of downloaded archive..."
  curl -sS -O "https://nextcloud.com/nextcloud.asc"
  gpg --import nextcloud.asc > /dev/null 2>&1
  gpg --verify "${nextcloud_archive}.asc" "${nextcloud_archive}" > /dev/null 2>&1
  # error and exit, if signature verification failed:
  if [[ $? != 0 ]]; then
    printf "\n%s\n" "-- ERROR: PGP signature verification failed. Downloaded archive seems to be corrupt. Exiting"
    exit 1
  fi
  printf "%s\n" " PGP signature valid!"
}

extract_archive() {
# extracts archive

  printf "%s" "+  extracting archive..."
  tar xfj "${nextcloud_archive}"
  printf "%s\n" " done!"
}

copy_config_data() {
# copies Nextclouds config.php and data directory (if nested in Nextclouds directory) to extracted archive (new Nextcloud directory)

  echo "+  copying Nextclouds configuration file"
  cp -a "${nextcloud_dir}/config/config.php" nextcloud/config/

  # check whether data directory resides inside Nextcloud directory. If yes: copy data directory as well
  if [[ -d "${nextcloud_dir}/data" ]]; then
    printf "%s" "+  copying datafolder (resides inside nextclouds directory)..."
    cp -a "${nextcloud_dir}/data" nextcloud/
    printf "%s\n" " done!"
  fi
}

adjust_permissions() {
# adjusts permissions for extracted archive (new Nextcloud directory)

  printf "%s" "+  adjusting file ownership and permissions (may take a while)..."
  chown -R ${htuser}:${htgroup} nextcloud
  find nextcloud/ -type d -exec chmod 750 {} \;
  find nextcloud/ -type f -exec chmod 640 {} \;
  printf "%s\n" " done!"
}

start_stop_webserver() {
# starts or stops webserver (depending on $1: start|stop)

  local text

  [[ "${1}" == "start" ]] && text="start"
  [[ "${1}" == "stop" ]] && text="stopp"
  echo "+  ${text}ing webserver"
  systemctl ${1} ${webserver_service}
}

rename_old_nextcloud() {
# adds current date and time to old Nextcloud folder to keep it as backup

  echo "+  renaming old Nextcloud folder by adding current date and time to foldername"
  mv "${nextcloud_dir}" "${nextcloud_dir}_${now}"
}

move_new_nextcloud() {
# moves the new Nextcloud folder to the location of Nextcloud-directory

  printf "%s" "+  moving new Nextcloud folder to desired location..."
  mv nextcloud "${nextcloud_dir}"
  printf "%s\n" " done!"
}

upgrade_nextcloud() {
# invokes Nextclouds occ upgrade script

  echo "+  invoking Nextclouds upgrade script:"
  sudo -u ${htuser} php "${nextcloud_dir}/occ" upgrade
}

clean_up() {
# cleans up:

  echo "+  removing temporary directory"
  rm -r /tmp/ncupgrade
}

print_footer() {
# prints a nice footer:

  echo "+  finished upgrade process."
  echo "+"
  echo "+  Don't forget to check output of nextclouds upgrade script for errors!"
  echo "+"
  echo "+  If there were any errors: use the backup to restore your previous installation:"
  echo "+  backed up folder of your previous installation is here: ${nextcloud_dir}_${now}"
  echo "+  and have a look at:"
  echo "+  https://github.com/nextcloud/documentation/blob/master/admin_manual/maintenance/manual_upgrade.rst#troubleshooting"
  echo "+"
  echo "+++++++++++++++++++++++++++++++++++++"
}

print_header
ask_for_version
read_configfile
maintenance_mode "on"
create_temp_dir
create_backup
download_archive
verify_checksum
verify_signature
extract_archive
copy_config_data
adjust_permissions
[[ "${stop_webserver}" != "no" ]] && start_stop_webserver "stop"
rename_old_nextcloud
move_new_nextcloud
[[ "${stop_webserver}" != "no" ]] && start_stop_webserver "start"
upgrade_nextcloud
maintenance_mode "off"
clean_up
print_footer

exit 0
