#!/bin/bash

# ncupgrade by BernieO - creates backup and upgrades Nextcloud according to documentation for manual upgrades
# Source: https://github.com/BernieO/ncupgrade
# Copyright (C) 2018 BernieO
#
# This script is licensed under the GNU AFFERO GENERAL PUBLIC LICENSE v3.0
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


#######################################################
#######################################################
##                                                   ##
##    Don't touch  anything below unless you know    ##
##           exactly what you are doing!             ##
##                                                   ##
#######################################################
#######################################################

set -euo pipefail

# for debugging purposes:
# set -x

# ncupgrade version:
ncupgrade_version="0.2.0 (23.03.2018), AGPL-3.0"

###
### BEGIN: FUNCTION DEFINITIONS
###

error_exit() {
# prints error message and exits script

  # print all arguments that have been passed to this function as error message:
  for message in "$@"; do
    echo "-- ${message}" >&2
  done
  echo "-- ncupgrade: Exiting." >&2

  # exit with error code 1
  exit 1
}

load_default_values() {
# loads default values into variables:

  backup_dir="nextcloud_backups"
  compression_method="tar.gz"
}

preparations() {
# does some preparational work (welcome message, make paths absolute, assign webserver user/group, set php_command)

  local my_identity temp

  #print welcome message:
  echo "+++++++++++++++++++++++++++++++++++++"
  echo "+"
  echo "+  ncupgrade version ${ncupgrade_version}"
  echo "+  This script creates backups and upgrades your Nextcloud installation."
  echo "+  Use at own risk!"
  echo "+"

  # make sure nextcloud_dir and backup_dir are absolute paths (because we switch to temporary directory later):
  nextcloud_dir="$(get_absolute_path "$(pwd)" "${nextcloud_dir}")"
  backup_dir="$(get_absolute_path "$(pwd)" "${backup_dir}")"

  # assign webserver user/group depending on owner of Nextclouds config.php:
  temp="$(stat --printf="%U:%G" "${nextcloud_dir}/config/config.php")"
  htuser="${temp%%:*}"
  htgroup="${temp##*:}"

  # set command for executing the occ command depending if run as 'root' or 'webserveruser':
  my_identity="$(whoami)"
  if [[ "${my_identity}" == "root" ]]; then
    # I am root, so use sudo to execute occ:
    php_command="sudo -u ${htuser}"
  else
    # I am not root, so check whether I am webserver user:
    if [[ "${my_identity}" == "${htuser}" ]]; then
      # I seem to be the webserver user, so I don't need any extra command to execute occ:
      php_command=""
    else
      # if I am neither root nor webserver user this script won't work - print error and exit:
      error_exit "ERROR: this script needs to be run either as root or as webserver user."
    fi
  fi
  echo "+  running as '${my_identity}'"
}

check_working_occ() {
# checks whether a call for occ is working and stores Nextcloud version in variable $nc_version

  local line regex="^.*( version)? [[:digit:]]{1,2}\.[[:digit:]]\.[[:digit:]]{1,2}$"

  # run occ command quietly:
  nc_version="$(${php_command} php "${nextcloud_dir}/occ" --no-warnings -V)"
  # tolerate that Nextcloud 10.0.0 reports itself as 10.0:
  [[ "${nc_version##* }" == "10.0" ]] && nc_version="Nextcloud version 10.0.0"

  # check output against regex and if not matching - print $nc_version (containing error message) and error exit:
  [[ "${nc_version}" =~ ${regex} ]] || {
    echo "${nc_version}"
    error_exit "ERROR: testing occ command returned an unexpected result. Can't proceed!"
  }
  # store version number for proper naming of backup files and comparing with download.nextcloud.com:
  nc_version="${nc_version##* }"

  # exclude ownCloud (check user documentation for word "Nextcloud" or "ownCloud":
  while read line; do
    [[ "${line}" =~ Nextcloud|ownCloud ]] && break
  done < ${nextcloud_dir}/core/doc/user/index.html
  [[ "${line}" =~ Nextcloud ]] || error_exit "ERROR: this seems to be an ownCloud installation." "ownCloud is not supported!"
}

check_available_version() {
# checks https://download.nextcloud.com/server/releases/ for latest available version of main version XX

  local regex_current regex_next middle_number regex_utv utv_available line

  # find out what would be the next major release:
  nc_version_next="${nc_version%%.*}"
  nc_version_next=$((nc_version_next+1))

  # regex for current version:
  regex_current="nextcloud-${nc_version%%.*}\..\..{1,2}\.tar\.bz2"
  # regex for next major version:
  regex_next="nextcloud-${nc_version_next}\..\..{1,2}\.tar\.bz2"
  # regex for specific version (set via option -utv):Â´
  [[ -z "${upgrade_to_version:-}" ]] || {
    middle_number="${upgrade_to_version%.*}"
    middle_number="${middle_number#*.}"
    regex_utv="nextcloud-${upgrade_to_version%%.*}\.${middle_number}\.${upgrade_to_version##*.}\.tar\.bz2"
  }

  # download and store website with all releases and check for lines containing regex_current or regex_next:
  while read line; do
    [[ "${line}" =~ ${regex_current} ]] && {
      # store line that contains main version number of installed Nextcloud. Last result will be latest available version:
      latest_available_current="${line##*nextcloud-}"
    }
    [[ "${line}" =~ ${regex_next} ]] && {
      # store line that contains next main version number of installed  Nextcloud. Last result will be latest available version:
      latest_available_next="${line##*nextcloud-}"
    }
    [[ -z "${upgrade_to_version:-}" ]] || {
      # if run with option -utv: check whether the desired version is available on Nextclouds download server:
      [[ "${line}" =~ ${regex_utv} ]] && utv_available="yes"
    }
  done <<<"$(curl -sS "https://download.nextcloud.com/server/releases/" | grep -E "(${regex_current}|${regex_next}|${regex_utv:-})")"

  # error and exit, if desired version passed via option -utv is not available on Nextclouds download server:
  if [[ -n "${regex_utv:-}" ]]; then
    [[ "${utv_available:-}" == "yes" ]] || error_exit "ERROR: specified version not available on Nextclouds download server!"
  fi

  # remove end of line to get version number of latest available point release of currently installed version:
  latest_available_current="${latest_available_current%%.tar.bz2*}"

  if [[ "${latest_available_current}" == "${nc_version}" ]]; then
    # latest available point release of currently installed version is already installed. Check whether next major version is available:
    if [[ -n ${latest_available_next:-} ]]; then
      latest_available_next="${latest_available_next%%.tar.bz2*}"
    fi
  fi
}

confirm_upgrade() {
# displays installed version and version to which the upgrade will be performed and asks for confirmation to upgrade

  local sure

  echo "+  Currently installed version is:   Nextcloud ${nc_version}"

  if [[ -n "${upgrade_to_version:-}" ]]; then
    # option -utv has been used: exclude forbidden upgrade paths (skipping major releases or downgrading):
    if [[ ${upgrade_to_version%%.*} -eq ${nc_version%%.*} ]]; then
      [[ ${upgrade_to_version##*.} -ge ${nc_version##*.} ]] || error_exit "ERROR: Downgrading is not supported!"
    else
      [[ ${upgrade_to_version%%.*} -gt ${nc_version%%.*} ]] || error_exit "ERROR: Downgrading is not supported!"
      [[ ${upgrade_to_version%%.*} -eq ${nc_version_next} ]] || error_exit "ERROR: Skipping major releases is not supported!"
    fi
  else
    if [[ "${latest_available_current}" != "${nc_version}" ]]; then
      # there is a newer point release of currently installed version available on the download page:
      echo "+  Latest available point release:   Nextcloud ${latest_available_current}"
      upgrade_to_version="${latest_available_current}"
      unset latest_available_current
    else
      # the currently installed version is already the latest point release:
      echo "+  Version ${nc_version} is the latest available point release of Nextcloud ${nc_version%%.*}"
      if [[ -n ${latest_available_next:-} ]]; then
        # the next major version is available on the download page:
        echo "+  However the next major release is available:   Nextcloud ${latest_available_next}"
        upgrade_to_version="${latest_available_next}"
        unset latest_available_next
      else
        # there is no upgrade available for the currently installed Nextcloud server:
        echo "+  Looks like the next major version (Nextcloud ${nc_version_next}) is not released yet."
        echo "+  There is no upgrade available for your Nextcloud server."
        echo "+  Exiting."
        echo "+"
        echo "+++++++++++++++++++++++++++++++++++++"
        exit 0
      fi
    fi
  fi

  # ask for confirmation:
  while read -r -n 2 -p "+  Confirm upgrade to version '${upgrade_to_version}' (y/n): " sure; do
    if [[ ${sure} = [YyNn] ]]; then
      [[ ${sure} = [Yy] ]] && {
        # if confirmed (Y or y): exit the while loop and proceed:
        printf "%s\n" "+  Confirmed. Starting upgrade"
        break
      }
      [[ ${sure} = [Nn] ]] && {
        # if not confirmed (N or n) error and exit:
        error_exit "ERROR: upgrade to ${upgrade_to_version} not confirmed."
      }
    else
      # if not a valid value was entered - print newline and repeat while loop:
      printf "\n"
    fi
  done

  # assign archive name according to entered version (using tar.bz2):
  nextcloud_archive="nextcloud-${upgrade_to_version}.tar.bz2"
}

get_absolute_path() {
  # returns the absolute path to a given filepath which may be absolute or relative to the directory from where the script has been invoked
  # this needs to be done because the script changes directories
  # arguments: ${1}=directory; ${2}=path to file (relative to ${1} or absolute)

  if [[ "${2}" != /* ]]; then
    # change path of ${2} (file) relative to ${1} (dir) to absolute path and remove trailing slashes:
    local absolute_path="$(readlink -f "${1}/${2}")"
    # error and exit if readlink could not canonicalize the given path and did return nothing:
    [[ "${absolute_path}" == "" ]] && error_exit "ERROR: path '${1}/${2}' can't be canonicalized" "Check given path!"
  else
    # if ${2} contains already absolute path, then only remove trailing slashes:
    local absolute_path="$(readlink -f "${2}")"
    # error and exit if readlink could not canonicalize the given path and did return nothing:
    [[ "${absolute_path}" == "" ]] && error_exit "ERROR: path '${2}' can't be canonicalized" "Check given path!"
  fi
  echo "${absolute_path}"
}

locate_data_dir() {
# retrieves location of Nextclouds data directory (we need to know that for eventually copying it to new Nextcloud directory)

  nc_data_dir="$(get_nc_config_value "datadirectory")"
}

maintenance_mode() {
# enables or disables Nextclouds maintenance mode (depending on $1: on|off)

  local text

  [[ "${1}" == "on" ]] && text="enabl"
  [[ "${1}" == "off" ]] && text="disabl"
  printf "%s" "+  ${text}ing Nextclouds maintenance mode... "
  ${php_command} php "${nextcloud_dir}/occ" --no-warnings maintenance:mode --${1}
}

create_temp_dir() {
# creates a temporary directory

  # create timestamp to append to backups:
  now=$(date +"%Y.%m.%d-%H.%M")

  echo "+  creating temporary directory"

  # store temp-directory in variable:
  temp_dir="/tmp/ncupgrade"

  # create temp directory:
  mkdir -p "${temp_dir}" || error_exit "ERROR: can't create temporary directory '${temp_dir}'"

  # check for write permission
  [[ -w "${temp_dir}" ]] || error_exit "ERROR: can't write in temporary directory '${temp_dir}'"

  # change to temporary directory (to have shorter download commands later)
  cd "${temp_dir}"

  # remove eventually existing files from previous run of this script (suppress error, if nothing is there to be removed):
  rm -rf *
}

get_nc_config_value() {
# reads value ($1) from Nextclouds system configuration

  local value

  value="$(${php_command} php "${nextcloud_dir}/occ" --no-warnings config:system:get ${1})"
  echo "${value}"
}

compress_backup() {
# compresses backed up and moves compressed backup to backup folder
# arguments:
#       $1 - path to be compressed (file or directory)
#       $2 - path (including filename) under which the compressed file shall be saved
#       $3 - name of item:
#                  data = Nextclouds data directory
#                  dir  = Nextcloud directory
#                  sql  = SQL dump
#       (timestamp and extension will be added in this function)

  local original_dir compress_error

  # store current directory (to be able to switch back):
  original_dir="$(pwd)"
  # change to directory that contains the directory or file to be compressed:
  cd "${1%/*}"

  # compress backup using the configured method (zip or tar.gz):
  if [[ "${compression_method}" == "zip" ]]; then
    # use zip to compress file or directory:
    zip -r -q "${2}_${now}_${3}.zip" "${1##*/}"
    # store error, to be able to print error message:
    [[ $? -eq 0 ]] || compress_error="1"
  else
    # use "tar.gz" as compression_method, in case invalid value was entered:
    compression_method="tar.gz"
    # use tar.gz to compress folder with backed up files:
    tar -czf "${2}_${now}_${3}.tar.gz" "${1##*/}"
    # store error, to be able to print error message:
    [[ $? -eq 0 ]] || compress_error="1"
  fi
  # print error message, if an error occured
  [[ "${compress_error:-}" == "1" ]] && error_exit "ERROR: Compressing the files produced an error. See lines right above."

  # change back to original directory:
  cd "${original_dir}"
}

backup_database() {
# creates a backup of Nextclouds database tables

  local dbtype dbhost dbprotocol dbname dbuser dbpassword PGPASSWORD dump_error

  printf "%s" "+  backing up database... "

  # first we need to find out which type of database is used (SQLite3, MySQL/MariaDB, PostgreSQL)
  dbtype="$(get_nc_config_value "dbtype")"

  if [[ "$dbtype" != "sqlite3" ]]; then
    # if database is not SQLite3 - we also need more things to know (dbhost, dbname, dbuser, dbpassword)
    dbhost="$(get_nc_config_value "dbhost")"
    dbname="$(get_nc_config_value "dbname")"
    dbuser="$(get_nc_config_value "dbuser")"
    dbpassword="$(get_nc_config_value "dbpassword")"

    # check whether dbhost contains socket (e.g. 'localhost:/path/to/socket') or portnumber (e.g. 'localhost:3306')
    #   and store it for commands:
    if [[ "${dbhost}" =~ ^.+:/.+$ ]]; then
      # dbhost contains socket after hostname (e.g. 'localhost:/var/run/mysqld/mysqld.sock'):
      if [[ "${dbtype}" == "mysql" ]]; then
        # specify socket and host for MySQL/MariaDB
        dbprotocol="--socket=${dbhost#*:}"
        dbhost="${dbhost%%:*}"
      elif [[ "${dbtype}" == "pgsql" ]]; then
        # use socket as host for PostgreSQL - see: https://www.postgresql.org/docs/current/static/app-pgdump.html:
        dbprotocol=""
        dbhost="${dbhost#*:}"
      fi
    elif [[ "${dbhost}" =~ ^.+:[[:digit:]]+$ ]]; then
      # dbhost contains portnumber after hostname (e.g. '127.0.0.1:3306'):
      dbprotocol="--port=${dbhost#*:}"
      dbhost="${dbhost%%:*}"
    else
      # dbhost contains only hostname - use empty value to tell database-command to use default value:
      dbprotocol=""
    fi

    if [[  "$dbtype" == "mysql" ]]; then
      # dump MySQL/MariaDB database:
      mysqldump --single-transaction -h ${dbhost} ${dbprotocol} -u ${dbuser} -p${dbpassword} ${dbname} > "${temp_dir}/nextcloud-sql.bak"
      # store error code - will be processed later:
      dump_error="$?"
    elif [[ "$dbtype" == "pgsql" ]]; then
      # dump PostgreSQL database:
      PGPASSWORD="${dbpassword}" pg_dump ${dbname} -h ${dbhost} ${dbprotocol} -U ${dbuser} -f "${temp_dir}/nextcloud-sql.bak"
      # store error code - will be processed later:
      dump_error="$?"
    fi
    # unset sensitive data:
    unset PGPASSWORD dbpassword dbuser

  elif [[ "$dbtype" == "sqlite3" ]]; then
    # dump sqlite3 database:
    sqlite3 ${nc_data_dir}/owncloud.db .dump > "${temp_dir}/nextcloud-sql.bak"
      # store error code - will be processed later:
      dump_error="$?"
  fi

  [[ "${dump_error}" != "0" ]] && error_exit "ERROR: could not create dump of database."

  # compress database backup and move it to backup folder:
  compress_backup "${temp_dir}/nextcloud-sql.bak" "${backup_dir}/nextcloud-${nc_version}" "sql"

  printf "%s\n" "done!"
}

backup_data_dir() {
# stores a compressed backup of Nextclouds data directory in backup directory

  local regex explanation

  # check whether data directory is located inside nextcloud directory:
  regex="^${nextcloud_dir}*"
  if [[ "${nc_data_dir}" =~ ${regex} ]]; then
    # data directory resides inside nextcloud directory:
    [[ -z "${exclude_data_directory:-}" ]] || explanation="- ignoring option '-ed'"
    echo "+  data directory is located inside Nextcloud directory ${explanation:-}"
  else
    if [[ "${exclude_data_directory:-}" == "yes" ]]; then
      echo "+  found option '-ed': not backing up data directory (located outside of Nextcloud folder)"
    else
      printf "%s" "+  backing up data directory (located outside of Nextcloud folder)... "
      # compress data directory and store it in backup directory:
      compress_backup "${nc_data_dir}" "${backup_dir}/nextcloud-${nc_version}" "data"
      printf "%s\n" "done!"
    fi
  fi
}

backup_nc_dir() {
# stores a compressed backup of Nextclouds directory in backup directory

  printf "%s" "+  backing up Nextcloud directory... "
  # compress Nextcloud directory and store it in backup directory:
  compress_backup "${nextcloud_dir}" "${backup_dir}/nextcloud-${nc_version}" "dir"
  printf "%s\n" "done!"
}

create_backup() {
# creates backup of Nextcloud installation based on official documentation:
# https://github.com/nextcloud/documentation/blob/master/admin_manual/maintenance/backup.rst

  # create backup directory (in case it does not exist yet), suppress error message. write test follows:
  mkdir -p "${backup_dir}" || error_exit "ERROR: can't create backup directory '${backup_dir}'"

  # check for write permission in backup directory:
  [[ -w "${backup_dir}" ]] || error_exit "ERROR: can't write in backup directory '${backup_dir}'"

  # Maintenance mode is already enabled at this stage of this script

  # Backup folders:
  backup_data_dir   # back up Nextclouds data directory (in case it is located outside Nextclouds directory)
  backup_nc_dir     # back up Nextcloud directory (contains then also config.php, themes and 3rd party apps)

  # Backup database:
  backup_database
}

get_files() {
# downloads Nextcloud archive, according SHA512 checksum and according PGP signature

  printf "%s" "+  downloading Nextcloud archive '${nextcloud_archive}', according checksum and PGP signature..."
  curl -sS -O "https://download.nextcloud.com/server/releases/${nextcloud_archive}"
  curl -sS -O "https://download.nextcloud.com/server/releases/${nextcloud_archive}.sha512"
  curl -sS -O "https://download.nextcloud.com/server/releases/${nextcloud_archive}.asc"
  printf "%s\n" " done!"
}

verify_checksum() {
# verifies SHA512 checksum of archive

  printf "%s" "+  verifying SHA512 checksum of downloaded archive... "

  # verify checksum - and error and exit, if checksum test failed:
  sha512sum -c "${nextcloud_archive}.sha512" < "${nextcloud_archive}" || error_exit "ERROR: checksum test failed. Downloaded archive seems to be corrupt."
}

verify_signature() {
# verifies PHP signature of archive

  printf "%s" "+  verifying PGP signature of downloaded archive..."
  curl -sS -O "https://nextcloud.com/nextcloud.asc"

  # import key - error and exit if not possible (missing permissions) error and exit:
  gpg --import nextcloud.asc > /dev/null 2>&1 || error_exit "ERROR: can't import Nextclouds PGP key. Verifying signature not possible."

  # verify signature - and error and exit, if signature verification failed:
  gpg --verify "${nextcloud_archive}.asc" "${nextcloud_archive}" > /dev/null 2>&1 || error_exit "ERROR: PGP signature verification failed. Downloaded archive seems to be corrupt."

  # if this script is still running the signature verification was positive
  printf "%s\n" " PGP signature valid!"
}

extract_archive() {
# extracts archive

  printf "%s" "+  extracting archive..."
  tar xfj "${nextcloud_archive}"
  printf "%s\n" " done!"
}

download_nextcloud() {
# downloads, verifies ans extracts desired Nextcloud archive:

  get_files
  verify_checksum
  verify_signature
  extract_archive
}

start_stop_webserver() {
# starts or stops webserver (depending on $1: start|stop)

  local text

  # only issue systemctl command if we are root. This is the case if $php_command is not empty:
  if [[ -n "${php_command}" ]]; then
    [[ "${1}" == "start" ]] && text="start"
    [[ "${1}" == "stop" ]] && text="stopp"
    echo "+  ${text}ing webserver"
    systemctl ${1} ${webserver_service}
  else
    echo "-- NOTICE: can't ${1} webserver, because not running as root."
  fi
}

rename_old_nextcloud() {
# adds current date and time to old Nextcloud folder to keep it as backup

  # check whether we have write permissions for parent directory of nextclouds directory:
  [[ -w "${nextcloud_dir%/*}" ]] || error_exit "ERROR: can't write in Nextclouds parent directory '${nextcloud_dir%/*}'"

  echo "+  renaming old Nextcloud folder (adding current date and time to foldername)"
  mv "${nextcloud_dir}" "${nextcloud_dir}_${now}"
}

move_new_nextcloud() {
# moves the new Nextcloud folder to the location of Nextcloud-directory

  printf "%s" "+  moving new Nextcloud folder to original location of old server..."
  mv nextcloud "${nextcloud_dir}"
  printf "%s\n" " done!"
}

copy_config() {
# copies Nextclouds config.php from old Nextcloud directory to new Nextcloud directory

  echo "+  copying config.php from old Nextcloud directory to new Nextcloud directory"
  cp -a "${nextcloud_dir}_${now}/config/config.php" "${nextcloud_dir}/config/"
}

copy_data() {
# copies Nextclouds data directory from old Nextcloud folder to new Nextcloud folder (only if it is located inside Nextcloud folder)

  local regex

  # check whether data directory is located inside nextcloud directory - if yes, copy it to new Nextcloud:
  regex="^${nextcloud_dir}*"
  if [[ "${nc_data_dir}" =~ ${regex} ]]; then
    printf "%s" "+  copying datafolder (resides inside Nextclouds directory) to new Nextcloud directory..."
    cp -a "${nextcloud_dir}_${now}/data" "${nextcloud_dir}/"
    printf "%s\n" " done!"
  fi
}

copy_3rd_party_apps() {
# check old Nextcloud directory for 3rd party applications that are missing in new Nextcloud directory
# and copy missing ones from old Nextcloud directory to new Nextcloud directory
# this is exactly the same function as copy_themes() below, but with using apps directory (instead of themes directory)

  local i count

  printf "%s\n" "+  looking for missing 3rd party applications in new Nextcloud directory:"
  count=0
  # go through apps directory from old Nextcloud, check if present in new Nextcloud and copy if not:
  for i in ${nextcloud_dir}_${now}/apps/*; do
    # make sure we are talking about a directory here:
    if [[ -d "$i" ]]; then
      # copy app to new Nextcloud, if not present in new Nextcloud/apps directory:
      if [[ ! -d "${nextcloud_dir}/apps/${i##*/}" ]]; then
        printf "%s\n" "+      copying app ${i##*/}"
        cp -a "$i" "${nextcloud_dir}/apps/"
        count=$((count+1))
      fi
    fi
  done
  [[ ${count} != 0 ]] || printf "%s\n" "+  no missing applications in new Nextcloud directory found."
}

copy_themes() {
# check old Nextcloud directory for (user created) themes that are missing in new Nextcloud directory
# and copy missing ones from old Nextcloud directory to new Nextcloud directory
# this is exactly the same function as copy_3rd_party_apps() above, but with using themes directory (instead of apps directory)

  local i count

  printf "%s\n" "+  looking for missing themes in new Nextcloud directory:"
  count=0
  # go through themes directory from old Nextcloud, check if present in new Nextcloud and copy if not:
  for i in ${nextcloud_dir}_${now}/themes/*; do
    # make sure we are talking about a directory here:
    if [[ -d "$i" ]]; then
      # copy theme to new Nextcloud, if not present in new Nextcloud/themes directory:
      if [[ ! -d "${nextcloud_dir}/themes/${i##*/}" ]]; then
        printf "%s\n" "+      copying theme ${i##*/}"
        cp -a "$i" "${nextcloud_dir}/themes/"
        count=$((count+1))
      fi
    fi
  done
  [[ ${count} != 0 ]] || printf "%s\n" "+  no missing themes in new Nextcloud directory found."
}

adjust_permissions() {
# adjusts permissions for Nextcloud directory

  printf "%s" "+  adjusting file ownership and permissions (may take a while)..."
  chown -R ${htuser}:${htgroup} "${nextcloud_dir}"
  find "${nextcloud_dir}/" -type d -exec chmod 750 {} \;
  find "${nextcloud_dir}/" -type f -exec chmod 640 {} \;
  printf "%s\n" " done!"
}

upgrade_nextcloud() {
# launches Nextclouds occ upgrade script

  echo "+  launching the upgrade from the command line using 'occ':"
  ${php_command} php "${nextcloud_dir}/occ" upgrade
}

clean_up() {
# cleans up the mess

  echo "+  removing old Nextcloud directory"
  rm -r "${nextcloud_dir}_${now}"
  echo "+  removing temporary directory"
  rm -r /tmp/ncupgrade
}

print_footer() {
# prints a nice footer:

  echo "+  finished upgrade process."
  echo "+"
  echo "+  Don't forget to check output of nextclouds upgrade script for errors!"
  echo "+"
  echo "+  If there were any errors - have a look at the troubleshooting section:"
  echo "+  https://github.com/nextcloud/documentation/blob/master/admin_manual/maintenance/manual_upgrade.rst"
  echo "+"
  echo "+  If you need to restore your previous installation, follow this guide:"
  echo "+  https://github.com/nextcloud/documentation/blob/master/admin_manual/maintenance/restore.rst"
  echo "+  Find the backup of your previous installation here:"
  echo "+     --> ${backup_dir}/"
  echo "+"
  echo "+++++++++++++++++++++++++++++++++++++"
}

print_help() {
# prints short help text

  echo "ncupgrade version ${ncupgrade_version}"
  echo "Usage: ./ncupgrade [DIRECTORY] [option [argument]] [option [argument]] [option [argument]] ..."
  echo "Find more details in attached file 'README.md' or visit 'https://github.com/BernieO/ncupgrade'"
}

check_argument() {
# checks for argument, if an option passed on command line needs an argument

  # if option was last on command line and no argument is following:
  [[ -n "${1:-}" ]] || error_exit "ERROR: Option '${option}' requires an additional argument."
  # if option was not last on command line, but an option (starting with a dash) is following instead of argument:
  [[ "${1:0:1}" != "-" ]] || error_exit "ERROR: Arguments for options may not start with a hyphen ('${1}')"
}

###
### END: FUNCTION DEFINITIONS
###

load_default_values

###
### BEGIN: parse command line for options/arguments
###

# error and exit if not a single argument was passed to the script:
[[ -n "${1:-}" ]] || error_exit "ERROR: path to Nextcloud directory is mandatory as first argument!"

# get nextcloud path (first given argument has to be the path to Nextclouds directory)
nextcloud_dir="${1}"
shift

# read options and their arguments and store them in according variables:
while [[ "${#}" -gt 0 ]]
do
  # store argument for error message, if invalid argument for option provided
  # (needed because of needed shift to get different arguments)
  option="${1}"

  case "${1}" in
    -bd | --backup-directory )
      shift
      check_argument "${1:-}"
      backup_dir="${1}"
    ;;
    -ed | --exclude-data-directory )
      exclude_data_directory="yes"
    ;;
    -h | --help )
      print_help
      exit 0
    ;;
    -k | --keep-webserver-running )
      stop_webserver="no"
    ;;
    -ob | --only-backup )
      only_backup="yes"
    ;;
    -utv | --upgrade-to-version )
      shift
      check_argument "${1:-}"
      upgrade_to_version="${1:-}"
    ;;
#    -rb | --restore-backup )
#       # not yet implemented
#       restore_backup
#       exit 0
#    ;;
    -w | --webserver )
      shift
      check_argument "${1:-}"
      stop_webserver="yes"
      webserver_service="${1}"
    ;;
    -z | --zip )
      compression_method="zip"
    ;;
    * )
      echo "-  WARNING! Unrecognized option: ${1}"
    ;;
  esac
  shift
done

###
### END: parse command line for options/arguments
###

preparations

if [[ "${only_backup:-}" == "yes" ]]; then
  # fond option -ob: only create a backup and then exit:
  echo "+  found option -ob: will only back up your Nextcloud"
  check_working_occ
  locate_data_dir
  maintenance_mode "on"
  create_temp_dir
  create_backup
  maintenance_mode "off"
  echo "+  removing temporary directory"
  rm -r /tmp/ncupgrade
  echo "+  Find the backup of your Nextcloud here:"
  echo "+     --> ${backup_dir}/"
  echo "+"
  echo "+++++++++++++++++++++++++++++++++++++"
  exit 0
fi

# we are going to do an upgrade, so make sure option -k or -w was passed to the script:
[[ -z "${stop_webserver:-}" ]] && error_exit "ERROR: missing mandatory option '-w WEBSERVER' or '-k'"
check_working_occ
check_available_version
confirm_upgrade
locate_data_dir
maintenance_mode "on"
create_temp_dir
create_backup
download_nextcloud
[[ "${stop_webserver}" == "yes" ]] && start_stop_webserver "stop"
rename_old_nextcloud
move_new_nextcloud
copy_config
copy_data
copy_3rd_party_apps
copy_themes
adjust_permissions
[[ "${stop_webserver}" == "yes" ]] && start_stop_webserver "start"
# only run upgrade script if installed version differs from previously installed version (possible via option -utv):
if [[ "${upgrade_to_version}" == "${nc_version}" ]]; then
  echo "+  no need to run upgrade script, because exactly same version has been installed"
else
  upgrade_nextcloud
fi
maintenance_mode "off"
clean_up
print_footer

exit 0
