#!/bin/bash

# ncupgrade by BernieO - upgrades Nextcloud to desired version (see examples/ncupgrade.conf)
# Source: https://github.com/BernieO/ncupgrade
# Copyright (C) 2017 BernieO
#
# This script is licensed under the GNU AFFERO GENERAL PUBLIC LICENSE v3.0
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


#######################################################
#######################################################
##                                                   ##
##    Don't touch  anything below unless you know    ##
##           exactly what you are doing!             ##
##                                                   ##
#######################################################
#######################################################

print_header() {
# prints a nice header with welcome message and advice to have a backup

  echo "+++++++++++++++++++++++++++++++++++++"
  echo "+"
  echo "+  This script will back up and upgrade your Nextcloud installation."
  echo "+  Use at own risk!"
  echo "+"
}

set_php_command() {
# sets the command for executing the occ command depending if user root or webserveruser

  local my_identity dir_list

  my_identity="$(whoami)"
  if [[ "${my_identity}" == "root" ]]; then
    # I am root, so use sudo to execute occ:
    php_command="sudo -u ${htuser}"
  else
    # I am not root, so check, whether config.php belongs to me (check whether my_identity is present in ls -l config.php):
    dir_list="$(ls -l "${nextcloud_dir}/config/config.php" 2>/dev/null)"
    if [[ "${dir_list}" =~ ${my_identity} ]]; then
      # config.php belongs to me, so I seem to be the webserver user. I don't need any extra command to execute occ:
      php_command=""
    else
      # if I am neither root nor webserver user this script won't work - print error and exit:
      echo "-- ERROR: this script needs to be run either as root or as webserver user. Exiting"
      exit 1
    fi
  fi
}

ask_for_version() {
# asks for version Nextcloud shall be upgraded to, makes sure a valid value is entered and assigns archive name for download

  local regex sure

  echo "+  To which version do you want to upgrade your Nextcloud?"
  echo "+  Please enter (X needs to be a digit):"
  echo "+    - either 'latest' to upgrade to latest available version"
  echo "+    - or 'latest-XX' to upgrade to latest available version of main version XX"

  # regex allows only "latest" or "latest-XX" (X must be a digit):
  regex='^latest(-[[:digit:]]{1,2})?$'
  # undocumented setting:
  # add 'allow_version_number="yes"' in ncupgrade.conf to allow entering an exact version number like XX.X.XX (e.g. '13.0.0') for testing purposes:
  [[ "${allow_version_number}" == "yes" ]] && regex='^([[:digit:]]{1,2}\.[[:digit:]]{1}\.[[:digit:]]{1,2}|latest(-[[:digit:]]{1,2})?)$'

  # ask for version to be upgraded to (and repeat if no valid value was entered):
  while [[ -z "${upgrade_to_version:-}" ]]; do
    read -r -p "+  Upgrade to version: " upgrade_to_version
    if [[ ! "${upgrade_to_version}" =~ ${regex} ]]; then
      echo "-- ERROR: not a valid value! Try again."
      echo "+  either enter 'latest' or 'latest-XX'"
      unset upgrade_to_version
    else
      # if valid value was entered - ask for confirmation, to make sure there is no typo:
      while read -r -n 1 -p "+  Confirm upgrade to version '${upgrade_to_version}' (Y/N): " sure; do
        if [[ ${sure} = [YyNn] ]]; then
          [[ ${sure} = [Yy] ]] && {
            # if confirmed (Y or y): exit the while loop and proceed:
            printf "\n%s\n" "+  Confirmed. Starting upgrade"
            break
          }
          [[ ${sure} = [Nn] ]] && {
            # if not confirmed (N or n) error and exit:
            printf "\n%s\n" "-- ERROR: upgrade to ${upgrade_to_version} not confirmed. Exiting"
            exit 1
          }
        else
          # if not a valid value was entered - print newline and repeat while loop:
          printf "\n"
        fi
      done
    fi
  done

  # assign archive name according to entered version (using tar.bz2, because zip doesn't contain permissions):
  if [[ "${upgrade_to_version}" =~ latest ]]; then
    # if 'latest' or 'latest-XX' was given it is enough to append '.tar.bz2':
    nextcloud_archive="${upgrade_to_version}.tar.bz2"
  else
    # if version number was given, archive is named nextcloud-XX.X.XX.tar.bz2:
    nextcloud_archive="nextcloud-${upgrade_to_version}.tar.bz2"
  fi
}

remove_trailing_slashes() {
# removes trailing slashes from given path/url

# arguments: $1 - path/url with possibly trailing slashes

  local path

  path="${1}"
  while [[ "${path}" =~ /$ ]]; do
    path="${path%/}"
  done
  echo "${path}"
}

read_configfile() {
# reads ncupgrades configfile ncupgrade.conf

  # check for existing ncupgrade onfig file:
  if [[ -f ncupgrade.conf ]]; then
    # read config file - this file needs to reside in the same directory as this script (see examples/ncupgrade.conf):
    echo "+  reading configuration file ncupgrade.conf"
    . ncupgrade.conf
  else
    # if no configuration file next to this script error and exit:
    echo "-- ERROR: Configuration file ncupgrade.conf not found."
    echo "-- This file needs to be in the same directory as this script."
    echo "-- See examples/ncupgrade.conf.example - Exiting."
    exit 1
  fi

  # remove trailing slashes from $nextcloud_dir and $backup_dir:
  nextcloud_dir="$(remove_trailing_slashes "${nextcloud_dir}")"
  backup_dir="$(remove_trailing_slashes "${backup_dir}")"
}

locate_data_dir() {
# retrieves location of Nextclouds data directory (we need to know that for eventually copying it to new Nextcloud directory)

  nc_data_dir="$(get_nc_config_value "datadirectory")"
}

maintenance_mode() {
# enables or disables Nextclouds maintenance mode (depending on $1: on|off)

  local text

  [[ "${1}" == "on" ]] && text="enabl"
  [[ "${1}" == "off" ]] && text="disabl"
  printf "%s" "+  ${text}ing Nextclouds maintenance mode... "
  ${php_command} php "${nextcloud_dir}/occ" --no-warnings maintenance:mode --${1}
}

check_write_permission() {
# checks whether I am able to write in given directory
# arguments: $1 - directory to check for write permission
#            $2 - explanation of directory

  # check whether I am able to write into directory:
  touch "${1}/testfile" 2>/dev/null
  if [[ "$?" == "1" ]]; then
    # I can't write in directory - error and exit:
    echo "-- ERROR: I am not allowed to write in ${2}. Exiting"
    exit 1
  else
    # I can write in directory - delete testfile:
    rm "${1}/testfile"
  fi
}

create_temp_dir() {
# creates a temporary directory

  # create timestamp to append to backups:
  now=$(date +"%Y.%m.%d-%H.%M")

  echo "+  creating temporary directory"

  # store temp-directory in variable:
  temp_dir="/tmp/ncupgrade"

  # create temp directory:
  mkdir -p "${temp_dir}" 2>/dev/null

  # check for write permission
  check_write_permission "${temp_dir}" "temporary directory"

  # change to temporary directory (to have shorter download commands later)
  cd "${temp_dir}"

  # remove eventually existing files from previous run of this script (suppress error, if nothing is there to be removed):
  rm -r * > /dev/null 2>&1
}

get_nc_config_value() {
# reads value ($1) from Nextclouds system configuration

  local value

  value="$(${php_command} php "${nextcloud_dir}/occ" --no-warnings config:system:get ${1})"
  echo "${value}"
}

compress_backup() {
# compresses backed up and moves compressed backup to backup folder
# arguments:
#       $1 - path to be compressed (file or directory)
#       $2 - path (including filename) under which the compressed file shall be saved
#                            (timestamp and extension will be added in this function)

  local original_dir compress_error

  # store current directory (to be able to switch back):
  original_dir="$(pwd)"
  # change to directory that contains the directory or file to be compressed:
  cd "${1%/*}"

  # compress backup using the configured method (zip or tar.gz):
  if [[ "${compression_method}" == "zip" ]]; then
    # use zip to compress file or directory:
    zip -r -q "${2}_${now}.zip" "${1##*/}"
    # store error, to be able to print error message:
    [[ $? -eq 0 ]] || compress_error="1"
  else
    # use "tar.gz" as compression_method, in case invalid value was entered:
    compression_method="tar.gz"
    # use tar.gz to compress folder with backed up files:
    tar -czf "${2}_${now}.tar.gz" "${1##*/}"
    # store error, to be able to print error message:
    [[ $? -eq 0 ]] || compress_error="1"
  fi
  # print error message, if an error occured
  [[ "${compress_error}" == "1" ]] && printf "\n%s\n" "-- ERROR: Compressing the files produced an error. See lines right above."

  # change back to original directory:
  cd "${original_dir}"
}

backup_database() {
# creates a backup of Nextclouds database tables

  local dbtype dbhost dbprotocol dbname dbuser dbpassword PGPASSWORD

  printf "%s" "+  backing up database... "

  # first we need to find out which type of database is used (SQLite3, MySQL/MariaDB, PostgreSQL)
  dbtype="$(get_nc_config_value "dbtype")"

  if [[ "$dbtype" != "sqlite3" ]]; then
    # if database is not SQLite3 - we also need more things to know (dbhost, dbname, dbuser, dbpassword)
    dbhost="$(get_nc_config_value "dbhost")"
    dbname="$(get_nc_config_value "dbname")"
    dbuser="$(get_nc_config_value "dbuser")"
    dbpassword="$(get_nc_config_value "dbpassword")"

    # check whether dbhost contains socket (e.g. 'localhost:/path/to/socket') or portnumber (e.g. 'localhost:3306')
    #   and store it for commands:
    if [[ "${dbhost}" =~ ^.+:/.+$ ]]; then
      # dbhost contains socket after hostname (e.g. 'localhost:/var/run/mysqld/mysqld.sock'):
      if [[ "${dbtype}" == "mysql" ]]; then
        # specify socket and host for MySQL/MariaDB
        dbprotocol="--socket=${dbhost#*:}"
        dbhost="${dbhost%%:*}"
      elif [[ "${dbtype}" == "pgsql" ]]; then
        # use socket as host for PostgreSQL - see: https://www.postgresql.org/docs/current/static/app-pgdump.html:
        dbprotocol=""
        dbhost="${dbhost#*:}"
      fi
    elif [[ "${dbhost}" =~ ^.+:[[:digit:]]+$ ]]; then
      # dbhost contains portnumber after hostname (e.g. '127.0.0.1:3306'):
      dbprotocol="--port=${dbhost#*:}"
      dbhost="${dbhost%%:*}"
    else
      # dbhost contains only hostname - use empty value to tell database-command to use default value:
      dbprotocol=""
    fi

    if [[  "$dbtype" == "mysql" ]]; then
      # dump MySQL/MariaDB database:
      mysqldump --single-transaction -h ${dbhost} ${dbprotocol} -u ${dbuser} -p${dbpassword} ${dbname} > "${temp_dir}/nextcloud-sql.bak"
    elif [[ "$dbtype" == "pgsql" ]]; then
      # dump PostgreSQL database:
      PGPASSWORD="${dbpassword}" pg_dump ${dbname} -h ${dbhost} ${dbprotocol} -U ${dbuser} -f "${temp_dir}/nextcloud-sql.bak"
    fi
    # unset sensitive data:
    unset PGPASSWORD dbpassword dbuser

  elif [[ "$dbtype" == "sqlite3" ]]; then
    # dump sqlite3 database:
    sqlite3 ${nc_data_dir}/owncloud.db .dump > "${temp_dir}/nextcloud-sql.bak"
  fi

  # compress database backup and move it to backup folder:
  compress_backup "${temp_dir}/nextcloud-sql.bak" "${backup_dir}/nextcloud-sql"

  printf "%s\n" "done!"
}

backup_data_dir() {
# stores a compressed backup of Nextclouds data directory in backup directory

  local regex

  # check whether data directory is located inside nextcloud directory:
  regex="^${nextcloud_dir}*"
  if [[ "${nc_data_dir}" =~ ${regex} ]]; then
    echo "+  data directory is located inside Nextcloud directory"
  else
    printf "%s" "+  backing up data directory (located outside of Nextcloud folder)... "
    # compress data directory and store it in backup directory:
    compress_backup "${nc_data_dir}" "${backup_dir}/nextcloud-data"
    printf "%s\n" "done!"
  fi
}

backup_nc_dir() {
# stores a compressed backup of Nextclouds directory in backup directory

  printf "%s" "+  backing up Nextcloud directory... "
  # compress Nextcloud directory and store it in backup directory:
  compress_backup "${nextcloud_dir}" "${backup_dir}/nextcloud-dir"
  printf "%s\n" "done!"
}

create_backup() {
# creates backup of Nextcloud installation based on official documentation:
# https://github.com/nextcloud/documentation/blob/master/admin_manual/maintenance/backup.rst

  # create backup directory (in case it does not exist yet), suppress error message. write test follows:
  mkdir -p "${backup_dir}" 2>/dev/null

  # check for write permission in backup directory:
  check_write_permission "${backup_dir}" "backup directory"

  # Maintenance mode is already enabled at this stage of this script

  # Backup folders:
  backup_data_dir   # back up Nextclouds data directory (in case it is located outside Nextclouds directory)
  backup_nc_dir     # back up Nextcloud directory (contains then also config.php, themes and 3rd party apps)

  # Backup database:
  backup_database
}

get_files() {
# downloads Nextcloud archive, according SHA512 checksum and according PGP signature

  printf "%s" "+  downloading Nextcloud archive '${nextcloud_archive}', according checksum and PGP signature..."
  curl -sS -O "https://download.nextcloud.com/server/releases/${nextcloud_archive}"
  curl -sS -O "https://download.nextcloud.com/server/releases/${nextcloud_archive}.sha512"
  curl -sS -O "https://download.nextcloud.com/server/releases/${nextcloud_archive}.asc"
  printf "%s\n" " done!"
}

verify_checksum() {
# verifies SHA512 checksum of archive

  printf "%s" "+  verifying SHA512 checksum of downloaded archive... "
  sha512sum -c "${nextcloud_archive}.sha512" < "${nextcloud_archive}"
  # error and exit, if checksum test failed:
  if [[ $? != 0 ]]; then
    printf "\n%s\n" "-- ERROR: checksum test failed. Downloaded archive seems to be corrupt. Exiting"
    exit 1
  fi
}

verify_signature() {
# verifies PHP signature of archive

  printf "%s" "+  verifying PGP signature of downloaded archive..."
  curl -sS -O "https://nextcloud.com/nextcloud.asc"
  gpg --import nextcloud.asc > /dev/null 2>&1
  # in case nextcloud.asc could not be imported to the keyring (missing permissions), don't verify signature:
  if [[ "$?" != "0" ]]; then
    printf "\n%s\n" "-- NOTICE: can't import key. Verifying signature not possible."
    echo "-- Proceeding without signature verification."
  else
    gpg --verify "${nextcloud_archive}.asc" "${nextcloud_archive}" > /dev/null 2>&1
    # error and exit, if signature verification failed:
    if [[ $? != 0 ]]; then
      printf "\n%s\n" "-- ERROR: PGP signature verification failed. Downloaded archive seems to be corrupt. Exiting"
      exit 1
    fi
    printf "%s\n" " PGP signature valid!"
  fi
}

extract_archive() {
# extracts archive

  printf "%s" "+  extracting archive..."
  tar xfj "${nextcloud_archive}"
  printf "%s\n" " done!"
}

download_nextcloud() {
# downloads, verifies ans extracts desired Nextcloud archive:

  get_files
  verify_checksum
  verify_signature
  extract_archive
}

start_stop_webserver() {
# starts or stops webserver (depending on $1: start|stop)

  local text

  # only issue systemctl command if we are root. This is the case if $php_command is not empty:
  if [[ -n "${php_command}" ]]; then
    [[ "${1}" == "start" ]] && text="start"
    [[ "${1}" == "stop" ]] && text="stopp"
    echo "+  ${text}ing webserver"
    systemctl ${1} ${webserver_service}
  else
    echo "-- NOTICE: can't ${1} webserver, because not running as root."
  fi
}

rename_old_nextcloud() {
# adds current date and time to old Nextcloud folder to keep it as backup

  # first check whether we have write permissions for parent directory of nextclouds directory:
  check_write_permission "${nextcloud_dir%/*}" "Nextclouds parent directory"

  echo "+  renaming old Nextcloud folder (adding current date and time to foldername)"
  mv "${nextcloud_dir}" "${nextcloud_dir}_${now}"
}

move_new_nextcloud() {
# moves the new Nextcloud folder to the location of Nextcloud-directory

  printf "%s" "+  moving new Nextcloud folder to original location of old server..."
  mv nextcloud "${nextcloud_dir}"
  printf "%s\n" " done!"
}

copy_config() {
# copies Nextclouds config.php from old Nextcloud directory to new Nextcloud directory

  echo "+  copying config.php from old Nextcloud directory to new Nextcloud directory"
  cp -a "${nextcloud_dir}_${now}/config/config.php" "${nextcloud_dir}/config/"
}

copy_data() {
# copies Nextclouds data directory from old Nextcloud folder to new Nextcloud folder (only if it is located inside Nextcloud folder)

  local regex

  # check whether data directory is located inside nextcloud directory - if yes, copy it to new Nextcloud:
  regex="^${nextcloud_dir}*"
  if [[ "${nc_data_dir}" =~ ${regex} ]]; then
    printf "%s" "+  copying datafolder (resides inside Nextclouds directory) to new Nextcloud directory..."
    cp -a "${nextcloud_dir}_${now}/data" "${nextcloud_dir}/"
    printf "%s\n" " done!"
  fi
}

copy_3rd_party_apps() {
# check old Nextcloud directory for 3rd party applications that are missing in new Nextcloud directory
# and copy missing ones from old Nextcloud directory to new Nextcloud directory
# this is exactly the same function as copy_themes() below, but with using apps directory (instead of themes directory)

  local i count

  printf "%s\n" "+  looking for missing 3rd party applications in new Nextcloud directory:"
  count=0
  # go through apps directory from old Nextcloud, check if present in new Nextcloud and copy if not:
  for i in ${nextcloud_dir}_${now}/apps/*; do
    # make sure we are talking about a directory here:
    if [[ -d "$i" ]]; then
      # copy app to new Nextcloud, if not present in new Nextcloud/apps directory:
      if [[ ! -d "${nextcloud_dir}/apps/${i##*/}" ]]; then
        printf "%s\n" "+      copying app ${i##*/}"
        cp -a "$i" "${nextcloud_dir}/apps/"
        (( count++ ))
      fi
    fi
  done
  [[ ${count} == 0 ]] && printf "%s\n" "+  no missing applications in new Nextcloud directory found."
}

copy_themes() {
# check old Nextcloud directory for (user created) themes that are missing in new Nextcloud directory
# and copy missing ones from old Nextcloud directory to new Nextcloud directory
# this is exactly the same function as copy_3rd_party_apps() above, but with using themes directory (instead of apps directory)

  local i count

  printf "%s\n" "+  looking for missing themes in new Nextcloud directory:"
  count=0
  # go through themes directory from old Nextcloud, check if present in new Nextcloud and copy if not:
  for i in ${nextcloud_dir}_${now}/themes/*; do
    # make sure we are talking about a directory here:
    if [[ -d "$i" ]]; then
      # copy theme to new Nextcloud, if not present in new Nextcloud/themes directory:
      if [[ ! -d "${nextcloud_dir}/themes/${i##*/}" ]]; then
        printf "%s\n" "+      copying theme ${i##*/}"
        cp -a "$i" "${nextcloud_dir}/themes/"
        (( count++ ))
      fi
    fi
  done
  [[ ${count} == 0 ]] && printf "%s\n" "+  no missing themes in new Nextcloud directory found."
}

adjust_permissions() {
# adjusts permissions for Nextcloud directory

  printf "%s" "+  adjusting file ownership and permissions (may take a while)..."
  chown -R ${htuser}:${htgroup} "${nextcloud_dir}"
  find "${nextcloud_dir/}" -type d -exec chmod 750 {} \;
  find "${nextcloud_dir/}" -type f -exec chmod 640 {} \;
  printf "%s\n" " done!"
}

upgrade_nextcloud() {
# launches Nextclouds occ upgrade script

  echo "+  launching the upgrade from the command line using 'occ':"
  ${php_command} php "${nextcloud_dir}/occ" upgrade
}

clean_up() {
# cleans up the mess

  echo "+  removing old Nextcloud directory (don't panic - you have a backup)"
  rm -r "${nextcloud_dir}_${now}"
  echo "+  removing temporary directory"
  rm -r /tmp/ncupgrade
}

print_footer() {
# prints a nice footer:

  echo "+  finished upgrade process."
  echo "+"
  echo "+  Don't forget to check output of nextclouds upgrade script for errors!"
  echo "+"
  echo "+  If there were any errors - have a look at the troubleshooting section:"
  echo "+  https://github.com/nextcloud/documentation/blob/master/admin_manual/maintenance/manual_upgrade.rst"
  echo "+"
  echo "+  If you need to restore your previous installation, follow this guide:"
  echo "+  https://github.com/nextcloud/documentation/blob/master/admin_manual/maintenance/restore.rst"
  echo "+  Find the backup of your previous installation here:"
  echo "+     --> ${backup_dir}/"
  echo "+"
  echo "+++++++++++++++++++++++++++++++++++++"
}

print_header
read_configfile
set_php_command
ask_for_version
locate_data_dir
maintenance_mode "on"
create_temp_dir
create_backup
download_nextcloud
[[ "${stop_webserver}" != "no" ]] && start_stop_webserver "stop"
rename_old_nextcloud
move_new_nextcloud
copy_config
copy_data
copy_3rd_party_apps
copy_themes
adjust_permissions
[[ "${stop_webserver}" != "no" ]] && start_stop_webserver "start"
upgrade_nextcloud
maintenance_mode "off"
clean_up
print_footer

exit 0
