#!/bin/bash

# ncupgrade by BernieO - creates backup and upgrades Nextcloud according to documentation for manual upgrades
# Source: https://github.com/BernieO/ncupgrade
# Copyright (C) 2018 BernieO
#
# This script is licensed under the GNU AFFERO GENERAL PUBLIC LICENSE v3.0
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


#######################################################
#######################################################
##                                                   ##
##    Don't touch  anything below unless you know    ##
##           exactly what you are doing!             ##
##                                                   ##
#######################################################
#######################################################

set -euo pipefail

# ncupgrade version:
ncupgrade_version="0.4.2 (24.07.2018), AGPL-3.0"

###
### BEGIN: FUNCTION DEFINITIONS
###

error_exit() {
# prints error message and exits script

  # print all arguments that have been passed to this function as error message:
  for message in "$@"; do
    echo "-- ${message}" >&2
  done
  echo "-- ncupgrade: Exiting." >&2

  # exit with error code 1
  exit 1
}

load_default_values() {
# loads default values into variables:

  backup_dir="nextcloud_backups"
  compression_method="tar.gz"
  # permissions for directories and files (user can change via option '-l' to 755/644)
  permd="750"
  permf="640"
}

preparations() {
# does some preparational work (welcome message, make paths absolute, assign webserver user/group, set php_command)

  local my_identity temp

  #print welcome message:
  echo "+++++++++++++++++++++++++++++++++++++"
  echo "+"
  echo "+  ncupgrade version ${ncupgrade_version}"
  echo "+  This script creates backups and upgrades your Nextcloud installation."
  echo "+  Use at own risk!"
  echo "+"

  # store working directory to be able to switch back later:
  original_dir="$(pwd)"

  # make sure nextcloud_dir and backup_dir are absolute paths (because we switch to temporary directory later):
  nextcloud_dir="$(get_absolute_path "${original_dir}" "${nextcloud_dir}")"
  backup_dir="$(get_absolute_path "${original_dir}" "${backup_dir}")"
  configphp="${nextcloud_dir}/config/config.php"

  # assign webserver user/group depending on owner of Nextclouds config.php:
  temp="$(stat --printf="%U:%G" "${configphp}")"
  htuser="${temp%%:*}"
  htgroup="${temp##*:}"

  # set command for executing the occ command depending if run as 'root' or 'webserveruser':
  my_identity="$(whoami)"
  if [[ "${my_identity}" == "root" ]]; then
    # I am root, so use sudo to execute occ:
    php_command="sudo -u ${htuser}"
  else
    # I am not root, so check whether I am webserver user:
    if [[ "${my_identity}" == "${htuser}" ]]; then
      # I seem to be the webserver user, so I don't need any extra command to execute occ:
      php_command=""
    else
      # if I am neither root nor webserver user this script won't work - print error and exit:
      error_exit "ERROR: this script needs to be run either as root or as webserver user."
    fi
  fi
  echo "+  running as '${my_identity}'"

  # create timestamp to append to backups:
  now=$(date +"%Y.%m.%d-%H.%M")
}

check_working_occ() {
# checks whether a call for occ is working and stores Nextcloud version in variable $nc_version

  local line regex="^.*( version)? [[:digit:]]{1,2}\.[[:digit:]]\.[[:digit:]]{1,2}$"

  # run occ command quietly:
  nc_version="$(${php_command} php "${nextcloud_dir}/occ" --no-warnings -V)"
  # tolerate that Nextcloud 10.0.0 reports itself as 10.0:
  [[ "${nc_version##* }" == "10.0" ]] && nc_version="Nextcloud version 10.0.0"

  # check output against regex and if not matching - print $nc_version (containing error message) and error exit:
  [[ "${nc_version}" =~ ${regex} ]] || {
    echo "${nc_version}"
    error_exit "ERROR: testing occ command returned an unexpected result. Can't proceed!"
  }
  # store version number for proper naming of backup files and comparing with download.nextcloud.com:
  nc_version="${nc_version##* }"

  # exclude ownCloud (check user documentation for word "Nextcloud" or "ownCloud":
  while read -r line; do
    [[ "${line}" =~ Nextcloud|ownCloud ]] && break
  done < "${nextcloud_dir}/core/doc/user/index.html"
  [[ "${line}" =~ Nextcloud ]] || error_exit "ERROR: this seems to be an ownCloud installation." "ownCloud is not supported!"
}

check_available_version() {
# checks https://download.nextcloud.com/server/releases/ for latest available version of main version XX

  local regex_current regex_next middle_number regex_utv utv_available line

  # find out what would be the next major release:
  nc_version_next="${nc_version%%.*}"
  nc_version_next=$((nc_version_next+1))

  # regex for current version:
  regex_current="nextcloud-${nc_version%%.*}\..\..{1,2}\.tar\.bz2"
  # regex for next major version:
  regex_next="nextcloud-${nc_version_next}\..\..{1,2}\.tar\.bz2"
  # regex for specific version (set via option -utv):Â´
  [[ -z "${upgrade_to_version:-}" ]] || {
    middle_number="${upgrade_to_version%.*}"
    middle_number="${middle_number#*.}"
    regex_utv="nextcloud-${upgrade_to_version%%.*}\.${middle_number}\.${upgrade_to_version##*.}\.tar\.bz2"
  }

  # download and store website with all releases and check for lines containing regex_current or regex_next:
  while read -r line; do
    [[ "${line}" =~ ${regex_current} ]] && {
      # store line that contains main version number of installed Nextcloud. Last result will be latest available version:
      latest_available_current="${line##*nextcloud-}"
    }
    [[ "${line}" =~ ${regex_next} ]] && {
      # store line that contains next main version number of installed  Nextcloud. Last result will be latest available version:
      latest_available_next="${line##*nextcloud-}"
    }
    [[ -z "${upgrade_to_version:-}" ]] || {
      # if run with option -utv: check whether the desired version is available on Nextclouds download server:
      [[ "${line}" =~ ${regex_utv} ]] && utv_available="yes"
    }
  done <<<"$(curl -sS "https://download.nextcloud.com/server/releases/" | grep -E "(${regex_current}|${regex_next}|${regex_utv:-})")"

  # error and exit, if desired version passed via option -utv is not available on Nextclouds download server:
  if [[ -n "${regex_utv:-}" ]]; then
    [[ "${utv_available:-}" == "yes" ]] || error_exit "ERROR: specified version not available on Nextclouds download server!"
  fi

  # remove end of line to get version number of latest available point release of currently installed version:
  latest_available_current="${latest_available_current%%.tar.bz2*}"

  if [[ "${latest_available_current}" == "${nc_version}" ]]; then
    # latest available point release of currently installed version is already installed. Check whether next major version is available:
    if [[ -n ${latest_available_next:-} ]]; then
      latest_available_next="${latest_available_next%%.tar.bz2*}"
    fi
  fi
}

confirm_upgrade() {
# displays installed version and version to which the upgrade will be performed and asks for confirmation to upgrade

  local sure

  echo "+  Currently installed version is:   Nextcloud ${nc_version}"

  if [[ -n "${upgrade_to_version:-}" ]]; then
    # option -utv has been used: exclude forbidden upgrade paths (skipping major releases or downgrading):
    if [[ ${upgrade_to_version%%.*} -eq ${nc_version%%.*} ]]; then
      [[ ${upgrade_to_version##*.} -ge ${nc_version##*.} ]] || error_exit "ERROR: Downgrading is not supported!"
    else
      [[ ${upgrade_to_version%%.*} -gt ${nc_version%%.*} ]] || error_exit "ERROR: Downgrading is not supported!"
      [[ ${upgrade_to_version%%.*} -eq ${nc_version_next} ]] || error_exit "ERROR: Skipping major releases is not supported!"
    fi
  else
    if [[ "${latest_available_current}" != "${nc_version}" ]]; then
      # there is a newer point release of currently installed version available on the download page:
      echo "+  Latest available point release:   Nextcloud ${latest_available_current}"
      upgrade_to_version="${latest_available_current}"
      unset latest_available_current
    else
      # the currently installed version is already the latest point release:
      echo "+  Version ${nc_version} is the latest available point release of Nextcloud ${nc_version%%.*}"
      if [[ -n ${latest_available_next:-} ]]; then
        # the next major version is available on the download page:
        echo "+  However the next major release is available:   Nextcloud ${latest_available_next}"
        upgrade_to_version="${latest_available_next}"
        unset latest_available_next
      else
        # there is no upgrade available for the currently installed Nextcloud server:
        echo "+  Looks like the next major version (Nextcloud ${nc_version_next}) is not released yet."
        echo "+  There is no upgrade available for your Nextcloud server."
        echo "+  Exiting."
        echo "+"
        echo "+++++++++++++++++++++++++++++++++++++"
        exit 0
      fi
    fi
  fi

  # ask for confirmation:
  while read -r -n 2 -p "+  Confirm upgrade to version '${upgrade_to_version}' (y/n): " sure; do
    if [[ ${sure} = [YyNn] ]]; then
      [[ ${sure} = [Yy] ]] && {
        # if confirmed (Y or y): exit the while loop and proceed:
        printf "%s\n" "+  Confirmed. Starting upgrade"
        break
      }
      [[ ${sure} = [Nn] ]] && {
        # if not confirmed (N or n) error and exit:
        error_exit "ERROR: upgrade to ${upgrade_to_version} not confirmed."
      }
    else
      # if not a valid value was entered - print newline and repeat while loop:
      [[ "${sure}" =~ ^.$ ]] || printf "\n"
    fi
  done

  # assign archive name according to entered version (using tar.bz2):
  nextcloud_archive="nextcloud-${upgrade_to_version}.tar.bz2"
}

get_absolute_path() {
# returns the absolute path to a given filepath which may be absolute or relative to the directory from where the script has been invoked
# this needs to be done because the script changes directories
# arguments: ${1}=directory; ${2}=path to file (relative to ${1} or absolute)

  local absolute_path
  if [[ "${2}" != /* ]]; then
    # change path of ${2} (file) relative to ${1} (dir) to absolute path and remove trailing slashes:
    absolute_path="$(readlink -vf "${1}/${2}")" || error_exit "ERROR: path '${1}/${2}' can't be canonicalized" "I need to be able to read the full path." "Check given path!"
  else
    # if ${2} contains already absolute path, then only remove trailing slashes:
    absolute_path="$(readlink -vf "${2}")" || error_exit "ERROR: path '${2}' can't be canonicalized" "I need to be able to read the full path." "Check given path!"
  fi
  echo "${absolute_path}"
}

locate_data_dir() {
# retrieves location of Nextclouds data directory (we need to know that for eventually copying it to new Nextcloud directory)

  nc_data_dir="$(getvalue_from_configphp "datadirectory")"
}

maintenance_mode() {
# enables or disables Nextclouds maintenance mode (depending on $1: on|off)

  local text

  [[ "${1}" == "on" ]] && text="enabl"
  [[ "${1}" == "off" ]] && text="disabl"
  printf "%s" "+  ${text}ing Nextclouds maintenance mode... "
  ${php_command} php "${nextcloud_dir}/occ" --no-warnings maintenance:mode --"${1}"
}

create_temp_dir() {
# creates a temporary directory

  echo "+  creating temporary directory"

  # store temp-directory in variable:
  temp_dir="/tmp/ncupgrade"

  # create temp directory:
  mkdir -p "${temp_dir}" || error_exit "ERROR: can't create temporary directory '${temp_dir}'"

  # check for write permission
  [[ -w "${temp_dir}" ]] || error_exit "ERROR: can't write in temporary directory '${temp_dir}'"

  # change to temporary directory (to have shorter download commands later)
  cd "${temp_dir}"

  # remove eventually existing files from previous run of this script (suppress error, if nothing is there to be removed):
  rm -rf ./*
}

getvalue_from_configphp() {
# reads a line with a given paramter from config.php and returns the parameters value
# arguments: ${1} is name of value that shall be returned

  # Notice: multi-line comments (/* ... */) are not recognized, if no marker at beginning of line. The first occurence of ${1} will be returned
  # This might be a problem: because wrong value might be returned, if value is also present in a multi-line comment before the actual declaration in config.php!

  local regex line

  regex="^[[:space:]]*'${1}'.*"
  while read -r line; do
    [[ "${line}" =~ $regex ]] && break
    line=""
  done <"${configphp}"

  # if parameter was found ($line is not empty) - manipulate $line to only return the value and nothing else:
  if [[ "${line:-}" != "" ]]; then
    if [[ ! "${line}" =~ \',$ ]]; then
      # in case it is a boolean value or a number (value not surrounded from '') - separate value:
      line=${line%,*}    # throw away end including last ","
      line=${line##* }   # throw away beginning including last SPACE
    else
      # value is surrounded from '' - separate the value:
      line=${line%\'*}   # throw away end including last '
      line=${line##*\'}  # throw away beginning including last '
    fi
  fi
  echo "${line:-}"
}

compress_backup() {
# compresses backed up and moves compressed backup to backup folder
# arguments:
#       $1 - path to be compressed (file or directory)
#       $2 - path (including filename) under which the compressed file shall be saved
#       $3 - name of item:
#                  data = Nextclouds data directory
#                  dir  = Nextcloud directory
#                  sql  = SQL dump
#       (timestamp and extension will be added in this function)

  local compress_error

  # change to directory that contains the directory or file to be compressed:
  cd "${1%/*}"

  # compress backup using the configured method (zip or tar.gz):
  if [[ "${compression_method}" == "zip" ]]; then
    # use zip to compress file or directory:
    zip -r -q "${2}_${now}_${3}.zip" "${1##*/}" || compress_error="$?"
  else
    # use "tar.gz" as compression_method, in case invalid value was entered:
    compression_method="tar.gz"
    # use tar.gz to compress folder with backed up files:
    tar -czf "${2}_${now}_${3}.tar.gz" "${1##*/}" || compress_error="$?"
  fi
  # print error message, if an error occured
  [[ "${compress_error:-0}" != "0" ]] && error_exit "ERROR: Compressing the files produced an error. See lines right above."

  # change back to original directory:
  cd "${original_dir}"
}

backup_database() {
# creates a backup of Nextclouds database tables

  local dbtype dbhost dbprotocol dbname dbuser dbpassword PGPASSWORD dump_error

  printf "%s" "+  backing up database... "

  # first we need to find out which type of database is used (SQLite3, MySQL/MariaDB, PostgreSQL)
  dbtype="$(getvalue_from_configphp "dbtype")"

  if [[ "$dbtype" != "sqlite3" ]]; then
    # if database is not SQLite3 - we also need more things to know (dbhost, dbname, dbuser, dbpassword)
    dbhost="$(getvalue_from_configphp "dbhost")"
    dbname="$(getvalue_from_configphp "dbname")"
    dbuser="$(getvalue_from_configphp "dbuser")"
    dbpassword="$(getvalue_from_configphp "dbpassword")"

    # check whether dbhost contains socket (e.g. 'localhost:/path/to/socket') or portnumber (e.g. 'localhost:3306')
    #   and store it for commands:
    if [[ "${dbhost}" =~ ^.+:/.+$ ]]; then
      # dbhost contains socket after hostname (e.g. 'localhost:/var/run/mysqld/mysqld.sock'):
      if [[ "${dbtype}" == "mysql" ]]; then
        # specify socket and host for MySQL/MariaDB
        dbprotocol="--socket=${dbhost#*:}"
        dbhost="${dbhost%%:*}"
      elif [[ "${dbtype}" == "pgsql" ]]; then
        # use socket as host for PostgreSQL - see: https://www.postgresql.org/docs/current/static/app-pgdump.html:
        dbprotocol=""
        dbhost="${dbhost#*:}"
      fi
    elif [[ "${dbhost}" =~ ^.+:[[:digit:]]+$ ]]; then
      # dbhost contains portnumber after hostname (e.g. '127.0.0.1:3306'):
      dbprotocol="--port=${dbhost#*:}"
      dbhost="${dbhost%%:*}"
    fi

    if [[  "$dbtype" == "mysql" ]]; then
      # dump MySQL/MariaDB database:
      if [[ -z "${dbprotocol:-}" ]]; then
        # no port or socket given in config.php:
        mysqldump --single-transaction -h "${dbhost}" -u "${dbuser}" -p"${dbpassword}" "${dbname}" > "${temp_dir}/nextcloud-sql.bak" || dump_error="$?"
      else
        # using port or socket as configured in config.php:
        mysqldump --single-transaction -h "${dbhost}" "${dbprotocol}" -u "${dbuser}" -p"${dbpassword}" "${dbname}" > "${temp_dir}/nextcloud-sql.bak" || dump_error="$?"
      fi
    elif [[ "$dbtype" == "pgsql" ]]; then
      # dump PostgreSQL database:
      if [[ -z "${dbprotocol:-}" ]]; then
        # no port or socket given in config.php:
        PGPASSWORD="${dbpassword}" pg_dump "${dbname}" -h "${dbhost}" -U "${dbuser}" -f "${temp_dir}/nextcloud-sql.bak" || dump_error="$?"
      else
        # using port or socket as configured in config.php:
        PGPASSWORD="${dbpassword}" pg_dump "${dbname}" -h "${dbhost}" "${dbprotocol}" -U "${dbuser}" -f "${temp_dir}/nextcloud-sql.bak" || dump_error="$?"
      fi
    fi
    # unset sensitive data:
    unset PGPASSWORD dbpassword dbuser

  elif [[ "$dbtype" == "sqlite3" ]]; then
    # dump sqlite3 database:
    sqlite3 "${nc_data_dir}/owncloud.db" .dump > "${temp_dir}/nextcloud-sql.bak" || dump_error="$?"
  fi

  [[ "${dump_error:-0}" != "0" ]] && error_exit "ERROR: could not create dump of database."

  # compress database backup and move it to backup folder:
  compress_backup "${temp_dir}/nextcloud-sql.bak" "${backup_dir}/nextcloud-${nc_version}" "sql"

  printf "%s\n" "done!"
}

backup_data_dir() {
# stores a compressed backup of Nextclouds data directory in backup directory

  local regex explanation

  # check whether data directory is located inside nextcloud directory:
  regex="^${nextcloud_dir}.*"
  if [[ "${nc_data_dir}" =~ ${regex} ]]; then
    # data directory resides inside nextcloud directory:
    [[ -z "${exclude_data_directory:-}" ]] || explanation="- ignoring option '-ed'"
    echo "+  data directory is located inside Nextcloud directory ${explanation:-}"
  else
    if [[ "${exclude_data_directory:-}" == "yes" ]]; then
      echo "+  found option '-ed': not backing up data directory (located outside of Nextcloud folder)"
    else
      printf "%s" "+  backing up data directory (located outside of Nextcloud folder)... "
      # compress data directory and store it in backup directory:
      compress_backup "${nc_data_dir}" "${backup_dir}/nextcloud-${nc_version}" "data"
      printf "%s\n" "done!"
    fi
  fi
}

backup_nc_dir() {
# stores a compressed backup of Nextclouds directory in backup directory

  printf "%s" "+  backing up Nextcloud directory... "
  # compress Nextcloud directory and store it in backup directory:
  compress_backup "${nextcloud_dir}" "${backup_dir}/nextcloud-${nc_version}" "dir"
  printf "%s\n" "done!"
}

create_backup() {
# creates backup of Nextcloud installation based on official documentation:
# https://github.com/nextcloud/documentation/blob/master/admin_manual/maintenance/backup.rst

  # create backup directory (in case it does not exist yet), suppress error message. write test follows:
  mkdir -p "${backup_dir}" || error_exit "ERROR: can't create backup directory '${backup_dir}'"

  # check for write permission in backup directory:
  [[ -w "${backup_dir}" ]] || error_exit "ERROR: can't write in backup directory '${backup_dir}'"

  # Maintenance mode is already enabled at this stage of this script

  # Backup folders:
  backup_data_dir   # back up Nextclouds data directory (in case it is located outside Nextclouds directory)
  backup_nc_dir     # back up Nextcloud directory (contains then also config.php, themes and 3rd party apps)

  # Backup database:
  backup_database
}

get_files() {
# downloads Nextcloud archive, according SHA512 checksum and according PGP signature

  cd "${temp_dir}"
  printf "%s" "+  downloading Nextcloud archive '${nextcloud_archive}', according checksum and PGP signature..."
  curl -sS -O "https://download.nextcloud.com/server/releases/${nextcloud_archive}"
  curl -sS -O "https://download.nextcloud.com/server/releases/${nextcloud_archive}.sha512"
  curl -sS -O "https://download.nextcloud.com/server/releases/${nextcloud_archive}.asc"
  printf "%s\n" " done!"
}

verify_checksum() {
# verifies SHA512 checksum of archive

  printf "%s" "+  verifying SHA512 checksum of downloaded archive... "

  # verify checksum - and error and exit, if checksum test failed:
  sha512sum -c "${nextcloud_archive}.sha512" < "${nextcloud_archive}" || error_exit "ERROR: checksum test failed. Downloaded archive seems to be corrupt."
}

verify_signature() {
# verifies PHP signature of archive

  printf "%s" "+  verifying PGP signature of downloaded archive..."
  curl -sS -O "https://nextcloud.com/nextcloud.asc"

  # import key - error and exit if not possible (missing permissions) error and exit:
  gpg --import nextcloud.asc > /dev/null 2>&1 || error_exit "ERROR: can't import Nextclouds PGP key. Verifying signature not possible."

  # verify signature - and error and exit, if signature verification failed:
  gpg --verify "${nextcloud_archive}.asc" "${nextcloud_archive}" > /dev/null 2>&1 || error_exit "ERROR: PGP signature verification failed. Downloaded archive seems to be corrupt."

  # if this script is still running the signature verification was positive
  printf "%s\n" " PGP signature valid!"
}

extract_archive() {
# extracts archive

  printf "%s" "+  extracting archive..."
  tar xfj "${nextcloud_archive}"
  printf "%s\n" " done!"
}

download_nextcloud() {
# downloads, verifies ans extracts desired Nextcloud archive:

  get_files
  verify_checksum
  verify_signature
  extract_archive
}

start_stop_webserver() {
# starts or stops webserver (depending on $1: start|stop)

  local text

  # only issue systemctl command if we are root. This is the case if $php_command is not empty:
  if [[ -n "${php_command}" ]]; then
    [[ "${1}" == "start" ]] && text="start"
    [[ "${1}" == "stop" ]] && text="stopp"
    echo "+  ${text}ing webserver"
    systemctl "${1}" "${webserver_service}"
  else
    echo "-- NOTICE: can't ${1} webserver, because not running as root."
  fi
}

rename_old_nextcloud() {
# adds current date and time to old Nextcloud folder to keep it as backup

  # check whether we have write permissions for parent directory of nextclouds directory:
  [[ -w "${nextcloud_dir%/*}" ]] || error_exit "ERROR: can't write in Nextclouds parent directory '${nextcloud_dir%/*}'"

  echo "+  renaming old Nextcloud folder (adding current date and time to foldername)"
  mv "${nextcloud_dir}" "${nextcloud_dir}_${now}"
}

move_new_nextcloud() {
# moves the new Nextcloud folder to the location of Nextcloud-directory

  printf "%s" "+  moving new Nextcloud folder to original location of old server..."
  mv nextcloud "${nextcloud_dir}"
  printf "%s\n" " done!"
}

copy_config() {
# copies Nextclouds config.php from old Nextcloud directory to new Nextcloud directory

  echo "+  copying config.php from old Nextcloud directory to new Nextcloud directory"
  cp -a "${nextcloud_dir}_${now}/config/config.php" "${nextcloud_dir}/config/"
}

copy_data() {
# copies Nextclouds data directory from old Nextcloud folder to new Nextcloud folder (only if it is located inside Nextcloud folder)

  local regex

  # check whether data directory is located inside nextcloud directory - if yes, copy it to new Nextcloud:
  regex="^${nextcloud_dir}.*"
  if [[ "${nc_data_dir}" =~ ${regex} ]]; then
    printf "%s" "+  copying datafolder (resides inside Nextclouds directory) to new Nextcloud directory..."
    cp -a "${nextcloud_dir}_${now}/data" "${nextcloud_dir}/"
    printf "%s\n" " done!"
  fi
}

copy_3rd_party_apps() {
# check old Nextcloud directory for 3rd party applications that are missing in new Nextcloud directory
# and copy missing ones from old Nextcloud directory to new Nextcloud directory
# this is exactly the same function as copy_themes() below, but with using apps directory (instead of themes directory)

  local i count

  printf "%s\n" "+  looking for missing apps in new Nextcloud directory:"
  count=0
  # go through apps directory from old Nextcloud, check if present in new Nextcloud and copy if not:
  for i in ${nextcloud_dir}_${now}/apps/*; do
    # make sure we are talking about a directory here:
    if [[ -d "$i" ]]; then
      # copy app to new Nextcloud, if not present in new Nextcloud/apps directory:
      if [[ ! -d "${nextcloud_dir}/apps/${i##*/}" ]]; then
        printf "%s\n" "+      copying app ${i##*/}"
        cp -a "$i" "${nextcloud_dir}/apps/"
        count=$((count+1))
      fi
    fi
  done
  [[ ${count} != 0 ]] || printf "%s\n" "+  no missing apps in new Nextcloud directory found."
}

copy_themes() {
# check old Nextcloud directory for (user created) themes that are missing in new Nextcloud directory
# and copy missing ones from old Nextcloud directory to new Nextcloud directory
# this is exactly the same function as copy_3rd_party_apps() above, but with using themes directory (instead of apps directory)

  local i count

  printf "%s\n" "+  looking for missing themes in new Nextcloud directory:"
  count=0
  # go through themes directory from old Nextcloud, check if present in new Nextcloud and copy if not:
  for i in ${nextcloud_dir}_${now}/themes/*; do
    # make sure we are talking about a directory here:
    if [[ -d "$i" ]]; then
      # copy theme to new Nextcloud, if not present in new Nextcloud/themes directory:
      if [[ ! -d "${nextcloud_dir}/themes/${i##*/}" ]]; then
        printf "%s\n" "+      copying theme ${i##*/}"
        cp -a "$i" "${nextcloud_dir}/themes/"
        count=$((count+1))
      fi
    fi
  done
  [[ ${count} != 0 ]] || printf "%s\n" "+  no missing themes in new Nextcloud directory found."
}

adjust_permissions() {
# adjusts permissions for Nextcloud directory
# arguments: $1 - if set to "datadir_as_well" adjust permissions also for Nextclouds data dir (this is for restoring data dir outside Nextcloud dir)

  printf "%s" "+  adjusting file ownership and permissions (may take a while)..."
  chown -R "${htuser}:${htgroup}" "${nextcloud_dir}"
  find "${nextcloud_dir}/" -type d -exec chmod ${permd} {} \;
  find "${nextcloud_dir}/" -type f -exec chmod ${permf} {} \;
  if [[ "${1:-}" == "datadir_as_well" ]]; then
    printf "%s\n" " done!"
    printf "%s" "+  adjusting file ownership and permissions for data directory (outside of Nextcloud)..."
    chown -R "${htuser}:${htgroup}" "${nc_data_dir}"
    find "${nc_data_dir}/" -type d -exec chmod ${permd} {} \;
    find "${nc_data_dir}/" -type f -exec chmod ${permf} {} \;
  fi
  printf "%s\n" " done!"
}

upgrade_nextcloud() {
# launches Nextclouds occ upgrade script

  echo "+  launching the upgrade from the command line using 'occ':"
  ${php_command} php "${nextcloud_dir}/occ" upgrade
}

manual_steps() {
# performs manual steps during upgrade

  local main_version dbtype

  # find out main version of freshly upgraded Nextcloud to perform according manual steps:
  main_version="$(getvalue_from_configphp "version")"
  main_version="${main_version%%.*}"

  if [[ ${main_version} -eq 13 ]]; then
    # perform manual steps for Nextcloud 13 according to:
    # https://docs.nextcloud.com/server/13/admin_manual/maintenance/upgrade.html#manual-steps-during-upgrade
    echo "+  performing manual steps after upgrade for Nextcloud 13:"
    echo "+  1. adding new index to share table:"
    ${php_command} php "${nextcloud_dir}/occ" db:add-missing-indices

    # find out which type of database is used (SQLite3, MySQL/MariaDB, PostgreSQL)
    dbtype="$(getvalue_from_configphp "dbtype")"
    if [[ "${dbtype}" == "sqlite3" ]]; then
      # switch to bigint not necessary for SQLite3 database, because sqlite3 uses dynamic Integer that can hold everything
      #     from 1 byte (tinyint) to 8 byte (bigint). See: http://www.sqlite.org/datatype3.html
      # SQLite doesn't care, so nothing to do:
      echo "+  2. skipping switch to bigint for file ID's in the file cache table: pointless for SQLite3"
    else
      # switch to bigint for MySQL/MariaDB and PostgreSQL:
      echo "+  2. switch to bigint for file ID's in the file cache table:"
      ${php_command} php "${nextcloud_dir}/occ" db:convert-filecache-bigint || :  # suppress error message in case answer to proceed was "n"
    fi
  fi
}

clean_up() {
# cleans up the mess

  echo "+  removing old Nextcloud directory"
  rm -r "${nextcloud_dir}_${now}"
  echo "+  removing temporary directory"
  rm -r /tmp/ncupgrade
}

print_footer() {
# prints a nice footer:

  echo "+  finished upgrade process."
  echo "+"
  echo "+  Don't forget to check output of nextclouds upgrade script for errors!"
  echo "+"
  echo "+  If there were any errors - have a look at the troubleshooting section:"
  echo "+  https://github.com/nextcloud/documentation/blob/master/admin_manual/maintenance/manual_upgrade.rst"
  echo "+"
  echo "+  If you need to restore your previous installation, use this command:"
  echo "+  ./ncupgrade ${nextcloud_dir} -rb -bd ${backup_dir}"
  echo "+"
  echo "+++++++++++++++++++++++++++++++++++++"
}

select_backup() {
# scan backup directory for available backups and let user choose which one to restore:

  local regex file temp i sure

  echo "+  Looking for backups in ${backup_dir}/"
  i=0
  # regex matches nextcloud_dir backed up with ncupgrade:
  regex="^.*/nextcloud-[[:digit:]]{1,2}\.[[:digit:]]\.[[:digit:]]{1,2}_[[:digit:]]{4}\.[[:digit:]]{2}\.[[:digit:]]{2}-[[:digit:]]{2}\.[[:digit:]]{2}_dir\.(tar\.gz|zip)$"
  for file in "${backup_dir}"/*; do
    if [[ "${file}" =~ ${regex} ]]; then
      i=$((i+1))
      backup_file[$i]="${file##*/}"
      temp="${file##*nextcloud-}"
      backup_vers[$i]="${temp%%_*}"
      temp="${temp#*_}"
      backup_date[$i]="${temp%%-*}"
      temp="${temp#*-}"
      backup_time[$i]="${temp%%_*}"
      echo "     $i:   Nextcloud ${backup_vers[$i]} - created ${backup_date[$i]}, ${backup_time[$i]}"
    fi
  done

  # exit with error, if no backups have been found:
  [[ ${i} -gt 0 ]] || error_exit "ERROR: no backups in backup directory found!"

  # let user choose which backup to restore:
  while read -r -n 2 -p "+  Enter number of backup to be restored (1-${i}): " n; do
    if [[ "${n}" =~ [0-9]{1,2} ]]; then
      if [[ ${n} -ge 1 && ${n} -le ${i} ]]; then
        # if valid number was entered: exit the while loop and proceed:
        break
      fi
    fi
    # if not a valid value was entered - repeat while loop (and print new line if two characters where entered):
    [[ "${n}" =~ ^.$ ]] || printf "\n"
  done

  # ask for confirmation:
  while read -r -n 2 -p "+  Confirm restore backup Nextcloud ${backup_vers[$n]} from ${backup_date[$n]}, ${backup_time[$n]} (y/n): " sure; do
    if [[ ${sure} = [YyNn] ]]; then
      [[ ${sure} = [Yy] ]] && {
        # if confirmed (Y or y): exit the while loop and proceed:
        printf "%s\n" "+  Confirmed. Starting to restore backup"
        break
      }
      [[ ${sure} = [Nn] ]] && {
        # if not confirmed (N or n) error and exit:
        error_exit "ERROR: restoring backup not confirmed."
      }
    else
      # if not a valid value was entered - print newline and repeat while loop:
      [[ "${sure}" =~ ^.$ ]] || printf "\n"
    fi
  done

  # use zip, if files from backup end with .zip:
  [[ "${backup_file[$n]}" =~ \.zip$ ]] && compression_method="zip"

  # assign filenames of according backup:
  nc_backup_dir="${backup_file[$n]}"
  nc_backup_sql="${backup_file[$n]%_*}_sql.${compression_method}"
  nc_backup_data="${backup_file[$n]%_*}_data.${compression_method}"
}

restore_nextcloud_dir() {
# restores nextcloud directory from backup

  printf "%s" "+  restoring Nextcloud directory... "

  # delete eventually existing Nextcloud directory at to be restored location:
  [[ -d "${nextcloud_dir}" ]] && rm -r "${nextcloud_dir}"

  # unpack Nextcloud dir from backup to desired location:
  if [[ "${compression_method}" == "tar.gz" ]]; then
    tar -xzf "${backup_dir}/${nc_backup_dir}" -C "${nextcloud_dir%/*}/"
  elif [[ "${compression_method}" == "zip" ]]; then
    unzip -q "${backup_dir}/${nc_backup_dir}" -d "${nextcloud_dir%/*}/"
  fi
  printf "%s\n" "done!"
}

restore_nextcloud_data() {
# restores nextcloud data directory (if found in backup and if residing outside of Nextclouds directory)

  local regex

  # find out whether data-directory is outside Nextclouds directory:
  locate_data_dir
  regex="^${nextcloud_dir}.*"
  if [[ "${nc_data_dir}" =~ ${regex} ]]; then
    # data directory resides inside nextcloud directory:
    echo "+  data directory is located inside Nextcloud directory. Already restored."
  else
    if [[ -r "${backup_dir}/${nc_backup_data}" ]]; then
      # delete eventually existing data dir:
      [[ -d "${nc_data_dir}" ]] && rm -r "${nc_data_dir}"
      # unpack Nextcloud dir from backup to desired location:
      printf "%s" "+  restoring data directory ${nc_data_dir} (outside Nextcloud dir)... "
      if [[ "${compression_method}" == "tar.gz" ]]; then
        tar -xzf "${backup_dir}/${nc_backup_data}" -C "${nc_data_dir%/*}/"
      elif [[ "${compression_method}" == "zip" ]]; then
        unzip -q "${backup_dir}/${nc_backup_data}" -d "${nc_data_dir%/*}/"
      fi
      printf "%s\n" "done!"

      # set variable so that permissions will be adjusted for data dir as well:
      adjust_permissions_datadir="datadir_as_well"

    else
      # print short message that data directory is located outside Nextcloud and no backup has been found:
      echo "+  no backup of data directory found (located outside of Nextcloud directory)."
      # set variable to do a filescan:
      scan_files="yes"
      [[ -d "${nc_data_dir}" ]] || data_dir_missing="yes" # data directory is neither in backup nor existing at configured location!
    fi
  fi
}

restore_nextcloud_database() {
# restores nextcloud database from backup

  local dbtype dbhost dbprotocol dbname dbuser dbpassword PGPASSWORD

  printf "%s" "+  restoring Nextcloud database... "

  # extract backup of database (path to extracted file will be "${temp_dir}/nextcloud-sql.bak"):
  if [[ "${compression_method}" == "tar.gz" ]]; then
    tar -xzf "${backup_dir}/${nc_backup_sql}" -C "${temp_dir}/"
  elif [[ "${compression_method}" == "zip" ]]; then
    unzip -q "${backup_dir}/${nc_backup_sql}" -d "${temp_dir}/"
  fi

  # find out which type of database is used (SQLite3, MySQL/MariaDB, PostgreSQL)
  dbtype="$(getvalue_from_configphp "dbtype")"

  if [[ "$dbtype" != "sqlite3" ]]; then
    # if database is not SQLite3 - we also need more things to know (dbhost, dbname, dbuser, dbpassword)
    dbhost="$(getvalue_from_configphp "dbhost")"
    dbname="$(getvalue_from_configphp "dbname")"
    dbuser="$(getvalue_from_configphp "dbuser")"
    dbpassword="$(getvalue_from_configphp "dbpassword")"

    # check whether dbhost contains socket (e.g. 'localhost:/path/to/socket') or portnumber (e.g. 'localhost:3306')
    #   and store it for commands:
    if [[ "${dbhost}" =~ ^.+:/.+$ ]]; then
      # dbhost contains socket after hostname (e.g. 'localhost:/var/run/mysqld/mysqld.sock'):
      if [[ "${dbtype}" == "mysql" ]]; then
        # specify socket and host for MySQL/MariaDB
        dbprotocol="--socket=${dbhost#*:}"
        dbhost="${dbhost%%:*}"
        # check for utf8mb4 value in config.php and assign according commands for recreating the database:
        mysql_utf8mb4="$(getvalue_from_configphp "mysql.utf8mb4")"
        [[ "${mysql_utf8mb4:-}" == "true" ]] && mysql_utf8mb4="CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci"
        [[ "${mysql_utf8mb4:-}" != "true" ]] && mysql_utf8mb4=""
     elif [[ "${dbtype}" == "pgsql" ]]; then
        # use socket as host for PostgreSQL:
        dbprotocol=""
        dbhost="${dbhost#*:}"
      fi
    elif [[ "${dbhost}" =~ ^.+:[[:digit:]]+$ ]]; then
      # dbhost contains portnumber after hostname (e.g. '127.0.0.1:3306'):
      dbprotocol="--port=${dbhost#*:}"
      dbhost="${dbhost%%:*}"
    else
      # dbhost contains only hostname - use empty value to tell database-command to use default value:
      dbprotocol=""
    fi
    if [[  "$dbtype" == "mysql" ]]; then
      # delete and recreate MySQL/MariaDB database:
      mysql --defaults-extra-file=<(printf "[client]\nuser = %s\npassword = %s\nhost = %s" "${dbuser}" "${dbpassword}" "${dbhost}") "${dbprotocol}" -se "DROP DATABASE IF EXISTS ${dbname}"
      mysql --defaults-extra-file=<(printf "[client]\nuser = %s\npassword = %s\nhost = %s" "${dbuser}" "${dbpassword}" "${dbhost}") "${dbprotocol}" -se "CREATE DATABASE ${dbname} ${mysql_utf8mb4}"

      # restore tables from backup in recreated database:
      mysql --defaults-extra-file=<(printf "[client]\nuser = %s\npassword = %s\nhost = %s" "${dbuser}" "${dbpassword}" "${dbhost}") "${dbprotocol}" "${dbname}" < "${temp_dir}/nextcloud-sql.bak"

    elif [[ "$dbtype" == "pgsql" ]]; then
      # delete and recreate PostgreSQL database:
      # NOTICE 1: psql in my environment doesn't require a password for the following commands.
      # If authentication is required, enter the password in the next line (PGPASSWORD will very likely be different from ${dbpassword} in Nextclouds config.php):
      pgsqlpassword=""
      # NOTICE 2: the commands in the official documentation do not work in my setup. I adapted them to work in my environment. Take note of alternative commands:
      # delete database:
      # documentation: PGPASSWORD="${dbpassword}" psql -h ${dbhost} ${dbprotocol} -U "${dbuser}" -d "${dbname}" -c "DROP DATABASE \"${dbname}\";"
      # alternative command: dropdb --if-exists "${dbname}"
      PGPASSWORD="${pgsqlpassword:-}" psql -q -h "${dbhost}" "${dbprotocol}" -d postgres -c "DROP DATABASE IF EXISTS \"${dbname}\";"
      # create database:
      # documentation: PGPASSWORD="${dbpassword}" psql -h ${dbhost} ${dbprotocol} -U "${dbuser}" -d "${dbname}" -c "CREATE DATABASE \"${dbname}\";"
      # alternative command: createdb --owner="${dbuser}" "${dbname}"
      PGPASSWORD="${pgsqlpassword:-}" psql -q -h "${dbhost}" "${dbprotocol}" -d postgres -c "CREATE DATABASE \"${dbname}\" OWNER \"${dbuser}\";"

      # restore tables from backup in recreated database
      # NOTICE 3: here ${dbpassword} from Nextclouds config.php is needed!:
      # documentation: PGPASSWORD="${dbpassword}" pg_restore -c -d ${dbname} -h ${dbhost} ${dbprotocol} -U ${dbuser} "${temp_dir}/nextcloud-sql.bak"
      PGPASSWORD="${dbpassword}" psql -q -d "${dbname}" -h "${dbhost}" "${dbprotocol}" -U "${dbuser}" -f "${temp_dir}/nextcloud-sql.bak" > /dev/null # supress lots of output

    fi
    # unset sensitive data:
    unset PGPASSWORD dbpassword dbuser

  elif [[ "$dbtype" == "sqlite3" ]]; then

    # delete sqlite3 database:
    rm "${nc_data_dir}/owncloud.db"
    # restore tables from backup in new database file:
    sqlite3 "${nc_data_dir}/owncloud.db" < "${temp_dir}/nextcloud-sql.bak"

  fi

  # remove extracted database-backup from $temp_dir:
  rm "${temp_dir}/nextcloud-sql.bak"

  printf "%s\n" "done!"
}

maintenance_data_fingerprint() {
# changes the ETag for all files. Available since Nextcloud 12.0
# see: https://docs.nextcloud.com/server/12/admin_manual/maintenance/restore.html

  local main_version

  main_version="$(getvalue_from_configphp "version")"
  main_version="${main_version%%.*}"
  # only run command if Nextcloud >= 12:
  if [[ ${main_version} -ge 12 ]]; then
    printf "%s" "+  changing the ETag for all files (maintenance:data-fingerprint)... "
    ${php_command} php "${nextcloud_dir}/occ" --no-warnings maintenance:data-fingerprint
    printf "%s\n" "done!"
  fi
}

files_scan_all() {
# deletes file cache and run file scan
# arguments: $1 - message why filescan was invoked

  echo "+  ${1}:"
  echo "+"

  # cleanup file cache:
  ${php_command} php "${nextcloud_dir}/occ" files:cleanup
  # scan all files:
  ${php_command} php "${nextcloud_dir}/occ" files:scan --all

  echo "+"
}

print_help() {
# prints short help text

  echo "ncupgrade version ${ncupgrade_version}"
  echo "Usage: ./ncupgrade [DIRECTORY] [option [argument]] [option [argument]] [option [argument]] ..."
  echo "Find more details in attached file 'README.md' or visit 'https://github.com/BernieO/ncupgrade'"
}

check_argument() {
# checks for argument, if an option passed on command line needs an argument

  # if option was last on command line and no argument is following:
  [[ -n "${1:-}" ]] || error_exit "ERROR: Option '${option}' requires an additional argument."
  # if option was not last on command line, but an option (starting with a dash) is following instead of argument:
  [[ "${1:0:1}" != "-" ]] || error_exit "ERROR: Arguments for options may not start with a hyphen ('${1}')"
}

###
### END: FUNCTION DEFINITIONS
###

load_default_values

###
### BEGIN: parse command line for options/arguments
###

# error and exit if not a single argument was passed to the script:
[[ -n "${1:-}" ]] || error_exit "ERROR: path to Nextcloud directory is mandatory as first argument!"

# get nextcloud path (first given argument has to be the path to Nextclouds directory)
nextcloud_dir="${1}"
shift

# read options and their arguments and store them in according variables:
while [[ "${#}" -gt 0 ]]
do
  # store argument for error message, if invalid argument for option provided
  # (needed because of needed shift to get different arguments)
  option="${1}"

  case "${1}" in
    -bd | --backup-directory )
      shift
      check_argument "${1:-}"
      backup_dir="${1}"
    ;;
    -ea | --exclude-apps )
      exclude_apps="yes"
    ;;
    -ed | --exclude-data-directory )
      exclude_data_directory="yes"
    ;;
    -et | --exclude-themes )
      exclude_themes="yes"
    ;;
    -h | --help )
      print_help
      exit 0
    ;;
    -k | --keep-webserver-running )
      stop_webserver="no"
    ;;
    -l | --less-restrictive-permissions )
      permd="755"
      permf="644"
    ;;
    -ob | --only-backup )
      only_backup="yes"
    ;;
    -rb | --restore-backup )
       restore_backup="yes"
    ;;
    -utv | --upgrade-to-version )
      shift
      check_argument "${1:-}"
      upgrade_to_version="${1:-}"
    ;;
    -w | --webserver )
      shift
      check_argument "${1:-}"
      stop_webserver="yes"
      webserver_service="${1}"
    ;;
    -z | --zip )
      compression_method="zip"
    ;;
    * )
      echo "-  WARNING! Unrecognized option: ${1}"
    ;;
  esac
  shift
done

###
### END: parse command line for options/arguments
###

preparations

if [[ "${only_backup:-}" == "yes" ]]; then
  # found option -ob: only create a backup and then exit:
  echo "+  found option -ob: will only back up your Nextcloud"
  check_working_occ
  locate_data_dir
  maintenance_mode "on"
  create_temp_dir
  create_backup
  maintenance_mode "off"
  echo "+  removing temporary directory"
  rm -r /tmp/ncupgrade
  echo "+  Find the backup of your Nextcloud here:"
  echo "+     --> ${backup_dir}/"
  echo "+"
  echo "+++++++++++++++++++++++++++++++++++++"
  exit 0
fi

if [[ "${restore_backup:-}" == "yes" ]]; then
  # found option -rb: restore backup and then exit:
  echo "+  found option -rb: will only restore your Nextcloud"
  select_backup
  create_temp_dir
  restore_nextcloud_dir
  restore_nextcloud_data
  restore_nextcloud_database
  adjust_permissions "${adjust_permissions_datadir:-}"
  # error and exit, if data directory is outside nextcloud_dir, not backed up and missing at configured location:
  [[ "${data_dir_missing:-}" == "yes" ]] && error_exit "ERROR: Nextclouds data directory is not present at configured location:" "${nc_data_dir}" "Nextcloud won't work until the data directory is restored!"
  maintenance_data_fingerprint
  maintenance_mode "off"
  [[ "${scan_files:-}" == "yes" ]] && files_scan_all "rescanning all files due to missing backup of data directory"
  rm -r /tmp/ncupgrade
  echo "+  restoring backup completed!"
  echo "+"
  echo "+++++++++++++++++++++++++++++++++++++"
  exit 0
fi

# we are going to do an upgrade, so make sure option -k or -w was passed to the script:
[[ -z "${stop_webserver:-}" ]] && error_exit "ERROR: missing mandatory option '-w WEBSERVER' or '-k'"
check_working_occ
check_available_version
confirm_upgrade
locate_data_dir
maintenance_mode "on"
create_temp_dir
create_backup
download_nextcloud
[[ "${stop_webserver}" == "yes" ]] && start_stop_webserver "stop"
rename_old_nextcloud
move_new_nextcloud
copy_config
copy_data
[[ "${exclude_apps:-}" == "yes" ]] || copy_3rd_party_apps
[[ "${exclude_themes:-}" == "yes" ]] || copy_themes
adjust_permissions
[[ "${stop_webserver}" == "yes" ]] && start_stop_webserver "start"
# run upgrade script IN maintenance-mode if installed version differs from previously installed version:
[[ "${upgrade_to_version}" != "${nc_version}" ]] && upgrade_nextcloud
manual_steps
maintenance_mode "off"
# run upgrade script AFTER switching off maintenance mode if version is same like previously installed version (possible via option -utv):
[[ "${upgrade_to_version}" == "${nc_version}" ]] && upgrade_nextcloud
clean_up
print_footer

exit 0
